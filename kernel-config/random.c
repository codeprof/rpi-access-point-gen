/*
 * random.c -- A strong random number generator
 *
 * Copyright (C) 2017 Jason A. Donenfeld <Jason@zx2c4.com>. All
 * Rights Reserved.
 *
 * Copyright Matt Mackall <mpm@selenic.com>, 2003, 2004, 2005
 *
 * Copyright Theodore Ts'o, 1994, 1995, 1996, 1997, 1998, 1999.  All
 * rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, and the entire permission notice in its entirety,
 *    including the disclaimer of warranties.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote
 *    products derived from this software without specific prior
 *    written permission.
 *
 * ALTERNATIVELY, this product may be distributed under the terms of
 * the GNU General Public License, in which case the provisions of the GPL are
 * required INSTEAD OF the above restrictions.  (This clause is
 * necessary due to a potential bad interaction between the GPL and
 * the restrictions contained in a BSD-style copyright.)
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ALL OF
 * WHICH ARE HEREBY DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF NOT ADVISED OF THE POSSIBILITY OF SUCH
 * DAMAGE.
 */

/*
 * (now, with legal B.S. out of the way.....)
 *
 * This routine gathers environmental noise from device drivers, etc.,
 * and returns good random numbers, suitable for cryptographic use.
 * Besides the obvious cryptographic uses, these numbers are also good
 * for seeding TCP sequence numbers, and other places where it is
 * desirable to have numbers which are not only random, but hard to
 * predict by an attacker.
 *
 * Theory of operation
 * ===================
 *
 * Computers are very predictable devices.  Hence it is extremely hard
 * to produce truly random numbers on a computer --- as opposed to
 * pseudo-random numbers, which can easily generated by using a
 * algorithm.  Unfortunately, it is very easy for attackers to guess
 * the sequence of pseudo-random number generators, and for some
 * applications this is not acceptable.  So instead, we must try to
 * gather "environmental noise" from the computer's environment, which
 * must be hard for outside attackers to observe, and use that to
 * generate random numbers.  In a Unix environment, this is best done
 * from inside the kernel.
 *
 * Sources of randomness from the environment include inter-keyboard
 * timings, inter-interrupt timings from some interrupts, and other
 * events which are both (a) non-deterministic and (b) hard for an
 * outside observer to measure.  Randomness from these sources are
 * added to an "entropy pool", which is mixed using a CRC-like function.
 * This is not cryptographically strong, but it is adequate assuming
 * the randomness is not chosen maliciously, and it is fast enough that
 * the overhead of doing it on every interrupt is very reasonable.
 * As random bytes are mixed into the entropy pool, the routines keep
 * an *estimate* of how many bits of randomness have been stored into
 * the random number generator's internal state.
 *
 * When random bytes are desired, they are obtained by taking the SHA
 * hash of the contents of the "entropy pool".  The SHA hash avoids
 * exposing the internal state of the entropy pool.  It is believed to
 * be computationally infeasible to derive any useful information
 * about the input of SHA from its output.  Even if it is possible to
 * analyze SHA in some clever way, as long as the amount of data
 * returned from the generator is less than the inherent entropy in
 * the pool, the output data is totally unpredictable.  For this
 * reason, the routine decreases its internal estimate of how many
 * bits of "true randomness" are contained in the entropy pool as it
 * outputs random numbers.
 *
 * If this estimate goes to zero, the routine can still generate
 * random numbers; however, an attacker may (at least in theory) be
 * able to infer the future output of the generator from prior
 * outputs.  This requires successful cryptanalysis of SHA, which is
 * not believed to be feasible, but there is a remote possibility.
 * Nonetheless, these numbers should be useful for the vast majority
 * of purposes.
 *
 * Exported interfaces ---- output
 * ===============================
 *
 * There are three exported interfaces; the first is one designed to
 * be used from within the kernel:
 *
 * 	void get_random_bytes(void *buf, int nbytes);
 *
 * This interface will return the requested number of random bytes,
 * and place it in the requested buffer.
 *
 * The two other interfaces are two character devices /dev/random and
 * /dev/urandom.  /dev/random is suitable for use when very high
 * quality randomness is desired (for example, for key generation or
 * one-time pads), as it will only return a maximum of the number of
 * bits of randomness (as estimated by the random number generator)
 * contained in the entropy pool.
 *
 * The /dev/urandom device does not have this limit, and will return
 * as many bytes as are requested.  As more and more random bytes are
 * requested without giving time for the entropy pool to recharge,
 * this will result in random numbers that are merely cryptographically
 * strong.  For many applications, however, this is acceptable.
 *
 * Exported interfaces ---- input
 * ==============================
 *
 * The current exported interfaces for gathering environmental noise
 * from the devices are:
 *
 *	void add_device_randomness(const void *buf, unsigned int size);
 * 	void add_input_randomness(unsigned int type, unsigned int code,
 *                                unsigned int value);
 *	void add_interrupt_randomness(int irq, int irq_flags);
 * 	void add_disk_randomness(struct gendisk *disk);
 *
 * add_device_randomness() is for adding data to the random pool that
 * is likely to differ between two devices (or possibly even per boot).
 * This would be things like MAC addresses or serial numbers, or the
 * read-out of the RTC. This does *not* add any actual entropy to the
 * pool, but it initializes the pool to different values for devices
 * that might otherwise be identical and have very little entropy
 * available to them (particularly common in the embedded world).
 *
 * add_input_randomness() uses the input layer interrupt timing, as well as
 * the event type information from the hardware.
 *
 * add_interrupt_randomness() uses the interrupt timing as random
 * inputs to the entropy pool. Using the cycle counters and the irq source
 * as inputs, it feeds the randomness roughly once a second.
 *
 * add_disk_randomness() uses what amounts to the seek time of block
 * layer request events, on a per-disk_devt basis, as input to the
 * entropy pool. Note that high-speed solid state drives with very low
 * seek times do not make for good sources of entropy, as their seek
 * times are usually fairly consistent.
 *
 * All of these routines try to estimate how many bits of randomness a
 * particular randomness source.  They do this by keeping track of the
 * first and second order deltas of the event timings.
 *
 * Ensuring unpredictability at system startup
 * ============================================
 *
 * When any operating system starts up, it will go through a sequence
 * of actions that are fairly predictable by an adversary, especially
 * if the start-up does not involve interaction with a human operator.
 * This reduces the actual number of bits of unpredictability in the
 * entropy pool below the value in entropy_count.  In order to
 * counteract this effect, it helps to carry information in the
 * entropy pool across shut-downs and start-ups.  To do this, put the
 * following lines an appropriate script which is run during the boot
 * sequence:
 *
 *	echo "Initializing random number generator..."
 *	random_seed=/var/run/random-seed
 *	# Carry a random seed from start-up to start-up
 *	# Load and then save the whole entropy pool
 *	if [ -f $random_seed ]; then
 *		cat $random_seed >/dev/urandom
 *	else
 *		touch $random_seed
 *	fi
 *	chmod 600 $random_seed
 *	dd if=/dev/urandom of=$random_seed count=1 bs=512
 *
 * and the following lines in an appropriate script which is run as
 * the system is shutdown:
 *
 *	# Carry a random seed from shut-down to start-up
 *	# Save the whole entropy pool
 *	echo "Saving random seed..."
 *	random_seed=/var/run/random-seed
 *	touch $random_seed
 *	chmod 600 $random_seed
 *	dd if=/dev/urandom of=$random_seed count=1 bs=512
 *
 * For example, on most modern systems using the System V init
 * scripts, such code fragments would be found in
 * /etc/rc.d/init.d/random.  On older Linux systems, the correct script
 * location might be in /etc/rcb.d/rc.local or /etc/rc.d/rc.0.
 *
 * Effectively, these commands cause the contents of the entropy pool
 * to be saved at shut-down time and reloaded into the entropy pool at
 * start-up.  (The 'dd' in the addition to the bootup script is to
 * make sure that /etc/random-seed is different for every start-up,
 * even if the system crashes without executing rc.0.)  Even with
 * complete knowledge of the start-up activities, predicting the state
 * of the entropy pool requires knowledge of the previous history of
 * the system.
 *
 * Configuring the /dev/random driver under Linux
 * ==============================================
 *
 * The /dev/random driver under Linux uses minor numbers 8 and 9 of
 * the /dev/mem major number (#1).  So if your system does not have
 * /dev/random and /dev/urandom created already, they can be created
 * by using the commands:
 *
 * 	mknod /dev/random c 1 8
 * 	mknod /dev/urandom c 1 9
 *
 * Acknowledgements:
 * =================
 *
 * Ideas for constructing this random number generator were derived
 * from Pretty Good Privacy's random number generator, and from private
 * discussions with Phil Karn.  Colin Plumb provided a faster random
 * number generator, which speed up the mixing function of the entropy
 * pool, taken from PGPfone.  Dale Worley has also contributed many
 * useful ideas and suggestions to improve this driver.
 *
 * Any flaws in the design are solely my responsibility, and should
 * not be attributed to the Phil, Colin, or any of authors of PGP.
 *
 * Further background information on this topic may be obtained from
 * RFC 1750, "Randomness Recommendations for Security", by Donald
 * Eastlake, Steve Crocker, and Jeff Schiller.
 */

#include <linux/atomic.h> //EDIT:

#include <linux/utsname.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/major.h>
#include <linux/string.h>
#include <linux/fcntl.h>
#include <linux/slab.h>
#include <linux/random.h>
#include <linux/poll.h>
#include <linux/init.h>
#include <linux/fs.h>
#include <linux/genhd.h>
#include <linux/interrupt.h>
#include <linux/mm.h>
#include <linux/nodemask.h>
#include <linux/spinlock.h>
#include <linux/kthread.h>
#include <linux/percpu.h>
#include <linux/cryptohash.h>
#include <linux/fips.h>
#include <linux/ptrace.h>
#include <linux/workqueue.h>
#include <linux/irq.h>
#include <linux/ratelimit.h>
#include <linux/syscalls.h>
#include <linux/completion.h>
#include <linux/uuid.h>
#include <crypto/chacha20.h>

#include <asm/processor.h>
#include <linux/uaccess.h>
#include <asm/irq.h>
#include <asm/irq_regs.h>
#include <asm/io.h>

#define CREATE_TRACE_POINTS
#include <trace/events/random.h>

/* #define ADD_INTERRUPT_BENCH */

/*
 * Configuration information
 */
#define INPUT_POOL_SHIFT	12
#define INPUT_POOL_WORDS	(1 << (INPUT_POOL_SHIFT-5))
#define OUTPUT_POOL_SHIFT	10
#define OUTPUT_POOL_WORDS	(1 << (OUTPUT_POOL_SHIFT-5))
#define SEC_XFER_SIZE		512
#define EXTRACT_SIZE		10


#define LONGS(x) (((x) + sizeof(unsigned long) - 1)/sizeof(unsigned long))

/*
 * To allow fractional bits to be tracked, the entropy_count field is
 * denominated in units of 1/8th bits.
 *
 * 2*(ENTROPY_SHIFT + log2(poolbits)) must <= 31, or the multiply in
 * credit_entropy_bits() needs to be 64 bits wide.
 */
#define ENTROPY_SHIFT 3
#define ENTROPY_BITS(r) ((r)->entropy_count >> ENTROPY_SHIFT)

/*
 * The minimum number of bits of entropy before we wake up a read on
 * /dev/random.  Should be enough to do a significant reseed.
 */
static int random_read_wakeup_bits = 256; //EDIT: 64;


//EDIT:

static const int myrandomness_A_size = 3529;
static const int myrandomness_B_size = 4339;
static const int myrandomness_A[] = {0x507DB012, 0x1F8FCB59, 0x76F07B6, 0x68C24E1, 0xE2D05DB5, 0xE63BEFF1, 0x380CBD66, 0xF153FE1, 0x8C1249B0, 0x571963D7, 0x6F94553E, 0x213B33A5, 0xD6E4C0FF, 0x7B9BFAA5, 0x13399136, 0xD8D803EA, 0x8058A876, 0xB0443C55, 0xA6987C6E, 0x449F8FCE, 0x9B1A01F2, 0xB08DD09E, 0x95256987, 0x10A00C0A, 0x91A4FAE8, 0x59DFCA42, 0x707FC5D0, 0x13AC947C, 0x48A60819, 0x64B809F2, 0xE4E9E520, 0x18D2FB68, 0x92D06A37, 0x36B0F8A7, 0x5E0F1544, 0x6E445B1D, 0x887C2331, 0x8DE528E5, 0x28E9E9D4, 0xF974BA74, 0x71586575, 0xD5FA5B1A, 0x7146C9B6, 0xCC76D03, 0x202022A1, 0xDACDC546, 0x5283360, 0x679980F6, 0x21DFC25F, 0x21B70B3E, 0x26E8D61C, 0x805C7926, 0x51321B01, 0x71F11FA9, 0xDC696909, 0x4D1AE3, 0x82637CE9, 0x7ADFF0, 0x83579BD0, 0xEB784242, 0xE63E4EAD, 0x70F4A566, 0x9B827BF0, 0x7F7DEF60, 0x278D1A33, 0xB6F6F37, 0xC5A34378, 0x93C77B1A, 0x1E464148, 0xB2BD114, 0x5160B2AA, 0x9B5B2C41, 0x31BD191F, 0x3E11863A, 0x8C199207, 0x34F12E5, 0x902D253D, 0x39E08777, 0x39448D76, 0x1FE0E8EC, 0xDC90F999, 0x517293B, 0xCFE156FF, 0xAD064D27, 0x435601DB, 0x5C5B09A9, 0x80F6C22F, 0x79F3694, 0x9705E387, 0xBC22E62F, 0x4E9C42BE, 0x9750C5F0, 0x910C0ABE, 0x4EDBF83C, 0x1C1DAADC, 0x223FD72, 0x9E18EAB, 0x7E81182C, 0x92D8AEA4, 0x66C5CC7C, 0xB0214FE2, 0xE129893B, 0xABAF91AC, 0xA3D8A24, 0x41846669, 0xDEA46685, 0x36D2D61A, 0xF9745B7B, 0x4135BC19, 0xE112A527, 0x8B9520A7, 0xC5BB6445, 0x59A97EF, 0x5D4ABBB0, 0x70649856, 0xFFDC7B16, 0x13EA1645, 0xB7BA56A, 0x108CDF90, 0x8470CF3C, 0xA973E75C, 0x286A0CE, 0x7719B551, 0x338458F9, 0xA00CAC0, 0xD4C8B927, 0xBDF6D01A, 0xA5F1AE0A, 0xEDE90F9D, 0x7C27F126, 0xEA77F217, 0x8263E1DE, 0x9D895002, 0xE706737E, 0x926E2A39, 0x23E07C8B, 0xECE3C5ED, 0x13D2CC7A, 0x8D0F3DA6, 0x6684015D, 0x98EEB229, 0xF37BA151, 0xD5187EEE, 0x3D7D3ECA, 0xDBD58BCB, 0xFAE9C652, 0x3D9F221A, 0x18ED2B11, 0xE2784624, 0xEBBBA61F, 0x37DB8F1D, 0x6D3A5F92, 0x1145955E, 0x40AFD404, 0x3E3F8D14, 0x12FC6563, 0xEB3B0C4C, 0x5ED01C15, 0x1FA783D9, 0x74D7C70B, 0xB385002B, 0x6B2299BB, 0x30777563, 0xD79D1EE4, 0xF9C3F29D, 0xAB71F2ED, 0x3CD50404, 0x1FED0B2B, 0x87BA4259, 0x8BACB7C3, 0x721B083A, 0x49212EC0, 0xD732E43B, 0x1B4D480, 0x750F07E, 0x9613818F, 0x3CC3D69, 0xC48C9BB1, 0x940BB67C, 0xA0EF679C, 0x5DD868BE, 0xB9C76039, 0x578ECCAC, 0x52460F3B, 0x17C24FA3, 0xFF6D612, 0x3CCA99B7, 0xAFDDD71D, 0xA3FB11BF, 0xC98C527E, 0x4E757124, 0x707A791D, 0x8B907334, 0x695AD07F, 0x4C530275, 0x8972EBFD, 0x31A8E38A, 0xA8251CC4, 0x8674FA4F, 0xEC1F1D3E, 0xB3008C08, 0x16459C1B, 0xADDA81DD, 0x9469FEA, 0xF9BAA1D2, 0x975E3D40, 0x953D37EA, 0x67277E08, 0xC9B3A3F2, 0x77C67180, 0x51F1D655, 0x7FB1AA2B, 0xA55A0D02, 0xC0194E12, 0x58CEC58E, 0xF5346811, 0xB5F45E6A, 0xAF730046, 0xE348AD46, 0xA660A778, 0x57FE7C32, 0x8E6C0411, 0x29F9D25A, 0x62F6D520, 0x9D56CD43, 0xFF70F2AE, 0xD082BD3F, 0xC9679EBA, 0xFCB9ADE5, 0x72543DD2, 0x2508E7D1, 0x32E77F7F, 0x40FD93F5, 0x1259E448, 0xA5012041, 0x7CF6DC0A, 0x27597FC, 0x70869A9B, 0x3E82DCFB, 0xA00082EE, 0xC00C5152, 0x5621F23D, 0x5F3332D, 0x1DCDA292, 0x76ED241F, 0x6B59C3BC, 0x6004242A, 0x2A769DFD, 0xFFD61544, 0x1B103FC9, 0x8D5CBB34, 0x57451B2A, 0xF8B67EC2, 0xEC24A213, 0x7E95ECC4, 0x14B195C1, 0x72861564, 0x82C29ED4, 0x249EE497, 0x94637BFC, 0x2925F58A, 0xF4DECE0F, 0x92C4FBA0, 0xD88C1BEF, 0x400085C4, 0xE16BDBCC, 0x756F87E5, 0xD7DE5F45, 0x4A10827E, 0x72B6566, 0x5D654378, 0xCAD032, 0xE060FB01, 0x1B8979A7, 0x9F8081D7, 0xF28C19E8, 0x82078DF9, 0x93EE7823, 0xE85C98F6, 0xA8C0A664, 0x13C83B6B, 0x82B403D5, 0x9247C9A2, 0x748C2218, 0x91EF1495, 0xE087C4C5, 0xCF4BB5FF, 0xDBC745D6, 0xD3B4E3EB, 0x6A625E49, 0x5E74595D, 0xD879E1BD, 0x18CA55BE, 0x64657223, 0xC10357E, 0x7DDC4DCB, 0x8190065F, 0x45C84325, 0x20DADA78, 0xDDCAD15B, 0xAF3939ED, 0x4573B6CA, 0xD95A2A5F, 0x8438EB1B, 0x75DD847C, 0x8998FAA0, 0x26C28054, 0x817A977F, 0x5FBD9DFE, 0x6A252B66, 0x5EBED655, 0xBD36F044, 0x6A31E4F2, 0xCB4261DF, 0x273D5EF6, 0xABAE5306, 0x2264C987, 0xDA0ECE5D, 0xC81BEC06, 0xCA362D06, 0x4CF2849F, 0x18B3F255, 0xBDD81FD1, 0x79A06477, 0x4490E6B9, 0x6C0A2FE0, 0xDF648C7F, 0x28140645, 0xAE55D3D8, 0xF971E339, 0x4251657F, 0xBE9CEC49, 0x8FD30D12, 0x5081D268, 0x901BF6FE, 0x1B943B6F, 0x76A1050A, 0x1C285A67, 0xD556A873, 0x1FD87669, 0x7CFCFF8D, 0x217F56FA, 0x4C9CCB6F, 0x7FE1FDDD, 0xBB3DB412, 0x34BFE54A, 0x182E6356, 0xEA52B631, 0x2D2065A2, 0xB859175B, 0xCA346B35, 0x9ABBEB17, 0x96FBE38A, 0x2ACBDF81, 0x37F38271, 0x3D6F1B42, 0x7ABD8CAA, 0xC91094B5, 0x3267371F, 0x5C633ECA, 0x3012D29B, 0x8624C75D, 0xBD73790D, 0x6BAAF9F3, 0x49DFB20D, 0x76567640, 0x912319F9, 0x775D4841, 0xE0B26A7B, 0x25C4BE1C, 0x31A723C8, 0xDC308D94, 0x9D953477, 0x8B7A05F, 0xE180AAA9, 0xC5D38A20, 0x51DEC1E1, 0xD55542D6, 0x81EF1E6C, 0xBC248EED, 0xD6401F64, 0xDB2D476, 0x86D19566, 0xEA5F0B07, 0x4973C623, 0xC5B47D67, 0xA1A50D99, 0xE2D4F077, 0xA107870, 0x1E696814, 0x3CEC17F0, 0x9CA8CD84, 0xBE694322, 0x254596F5, 0x926252C1, 0xCE303AD5, 0xFF9BCA3B, 0xE0BA8F82, 0x1D0BB1AA, 0x9A1ECF00, 0xCA2FA1A6, 0xC5807492, 0x635C6BC0, 0x95932171, 0xBB5F0C74, 0xB679905C, 0x16F9F169, 0xE5DD400C, 0x253B8316, 0x3DB2D716, 0xE7EDE4AD, 0xCFB8DA74, 0xA1F86D81, 0xFE0FE1C5, 0x6C0A7F6F, 0xC13CCCA5, 0x21F1442A, 0x663FA8B3, 0x4BE1853D, 0x80E7B5B6, 0x8E541590, 0xE14D7F80, 0x296F40E6, 0xC26EC90F, 0xE3B811BE, 0xA18F08BE, 0xEADAA2D3, 0x6B35FD80, 0x6C4C91E1, 0xA7FFEAA1, 0xB458D3E6, 0xE7CC4BCA, 0xB0A21C23, 0xE063A548, 0x7BAFBB45, 0x841C1D48, 0x425D5B57, 0xBB947903, 0x2B0640C9, 0x1D4B32F6, 0x9A00A801, 0xDA415828, 0x733BE14E, 0x43C1186E, 0x450E9C16, 0x9B1EFA6B, 0x90BE641A, 0x3034593D, 0x6F16FE8, 0x966A2F5B, 0x94BA20A2, 0x58D53DB5, 0x94E75FAB, 0x1460D47C, 0x40015DD0, 0x6440E147, 0x490D9625, 0xA5F43391, 0xB76F1C53, 0x67717088, 0xF5F82C7, 0x8E706DD9, 0x5689F205, 0xF402C743, 0x48D94E6, 0x26A9B815, 0x32907628, 0x3D0E9A31, 0x33D14733, 0x63626698, 0x2180CCDA, 0xCE98A842, 0x385FDF46, 0x530DD8A8, 0x965C953F, 0x112909B2, 0x1DB54E25, 0xEBEDFC46, 0x2EE1639D, 0xE99EE720, 0xBB1CF263, 0x931452DF, 0x3DF385C5, 0x9192D62, 0xC47B1B7C, 0x65AFE133, 0x770DE869, 0x757637B9, 0xD2F88F75, 0xAA903916, 0xD4BEB437, 0x5EB91D3A, 0x4943AB6C, 0x3048D9D5, 0x28256C4A, 0x8FDF8605, 0xDF4822A9, 0x1A3CDC52, 0x69A381AF, 0xB357EB0A, 0x67C1AEAB, 0x7F57818A, 0x210EBE99, 0xA86C2107, 0x4CF9794E, 0x3E3DA7CC, 0x83AA2ABA, 0x8F938A0E, 0xF596723A, 0x75F574A9, 0x1D265D6C, 0x703C8300, 0x5026998, 0x8D2105FA, 0x38C14549, 0x8E4DED8D, 0x2B50F699, 0xBAA0FDD9, 0x9B83ECB, 0xEC864FD4, 0x5AC76080, 0xE9BB7D98, 0x31ECB263, 0x51B69052, 0x692F3933, 0x4D5FDBA9, 0x8071D2EA, 0x254DEB75, 0x52903CF3, 0x81362C1, 0x2275B1FC, 0x62598A19, 0x206321F6, 0xC9969D9B, 0x6FB1FC9C, 0xC1F4D7D7, 0xBAD6DC17, 0x82B205FD, 0x7CDC191F, 0x9B290750, 0x24062BA8, 0x595B394F, 0x55A3F74E, 0xD9CB301E, 0x536E1C9D, 0xB0ACE687, 0x71A28E8D, 0xDCFC4033, 0xB66E940F, 0xAA44EDF4, 0x4DA6F5BA, 0x684BEC4, 0x65495D9B, 0x194581D9, 0x8A2E7056, 0xCABF39DA, 0xC928825E, 0x6AE88174, 0x75F83B5, 0x4CD8C0B8, 0x91D84122, 0x69D35D19, 0x805C7137, 0x61E2687, 0xA55E1954, 0xD5B03413, 0xC3AE6AE2, 0xEA0202A8, 0x918AA041, 0x3915F4EA, 0x13E1847D, 0x834E724D, 0xFC570EE8, 0x4FCCF024, 0x1D7626DE, 0xD632D1C0, 0x308F4800, 0x22A2B3B0, 0xE27BEC86, 0x9C6A4BA8, 0x43D646B, 0x18E7F671, 0xB5532BE8, 0x24B43C2, 0x59094A97, 0xE3A1CF2B, 0x683FD1FA, 0x41D0135E, 0x925786E8, 0x11A4331F, 0x121C57E5, 0xD27D0199, 0x90C3874D, 0x38809535, 0x9B81A66, 0x97708DB1, 0x8A4043F8, 0xE8E6B209, 0x81DAA216, 0x21E56F83, 0x726C5CED, 0x9F3E40A3, 0x9F519723, 0x8A840195, 0x7AC45B5, 0x875A31C4, 0x95ADCD3, 0x73176847, 0xBF6E8175, 0xEB465821, 0x306320A5, 0xE9AA6D50, 0x130DFDF9, 0x2BEC895D, 0xDAD9642C, 0xC23AB29E, 0x36BC0FDF, 0x5FCC0D1D, 0x3FF33A57, 0x8336E573, 0xF2197BA0, 0xB9272DB5, 0x64E92F27, 0xC270D462, 0x19A5789E, 0x9374854D, 0x615973DA, 0xC1D7121D, 0x5E4A7590, 0x1A36F2E8, 0xB312C054, 0x668AA82F, 0xD2DE5856, 0x6A806B61, 0x8B555BDD, 0x8569AF38, 0x3E67D745, 0x5507C20F, 0x817D4D2D, 0xF79CB0AB, 0xC1F7839F, 0x6D6FC1DB, 0x73749C57, 0x1109608E, 0x6E4ECEF2, 0x9FA1D009, 0x465B192, 0xDC0410A3, 0x328FF8C8, 0x44F40ECB, 0x7DE3A61B, 0xAB2C0620, 0x2C847CCE, 0xF960974B, 0xEE321989, 0x73C6681B, 0x61C15651, 0x2E5491F4, 0x7B8F55F7, 0x9595FDFC, 0x80E9EAC4, 0xF70A5861, 0xAF8EBB7F, 0x1376E4E1, 0xA1887A73, 0x88AFEEE5, 0x62D7B040, 0x33284EDE, 0x3B5E67D, 0x9A8D2689, 0x5D2E2C5A, 0x378CB8CE, 0x5BE979A2, 0x5FDF86DD, 0xC22F4963, 0x8DDCBB28, 0x87C1A894, 0x75C10BF4, 0x801EAC38, 0x36653CF9, 0x73A44BAC, 0xEE5735C1, 0xA22185A6, 0x48730963, 0x276FEA72, 0x22BCC5C1, 0xAD48A80A, 0x20CA6FC0, 0x4A35B751, 0x50557BA, 0x31463E75, 0xE17C674B, 0x393FD01E, 0x818E2B8F, 0xDE111DF, 0xED9FA3BC, 0x30F77E1D, 0x9D1DBE6D, 0x53076813, 0x97BE0ECF, 0xD04B8A95, 0xBA5922A0, 0xFE5552E9, 0x54AEB7C0, 0x2E92D7F8, 0xB75252CD, 0x43D39D62, 0x2B598A24, 0x7BB3BBDC, 0xCEF8364E, 0x1AA4F25B, 0x49599F49, 0x3373A970, 0xD229DB8, 0xFE6E8CEC, 0x40602545, 0xEB56FBA1, 0xEEF35FBE, 0xC18B954A, 0x5DC7C766, 0x1A7939C2, 0x27062BBC, 0xE91A00C2, 0x44F77D31, 0x80944895, 0xF2AB41E7, 0x38125763, 0xB38A84E6, 0x2319D91D, 0x2413F0AE, 0x7604286B, 0xA783573D, 0xC8DF6FE6, 0x5B1A7C54, 0x56AEAE6B, 0x5D59E2D5, 0x13AA2BE0, 0x515B419B, 0x97FFD32B, 0x7A2B26EA, 0xC2F32349, 0xF9E3D7E8, 0x61F6D5F9, 0xC6B97518, 0x613E0B2B, 0xD8A5781E, 0x935E0A3C, 0xC199E0ED, 0x95FD6F2F, 0xF240F143, 0x3AC9CD56, 0x3BC9E78D, 0x645C142D, 0x67D58CC, 0x7823F7CE, 0x494F10D6, 0xFB790FE7, 0xB92855BB, 0x98ACD018, 0xB76FF2EE, 0x4DC0F95F, 0xB0D8AD54, 0x255B1465, 0x8526D349, 0x9A3996E7, 0xCD9B5477, 0x3CA8AC6A, 0x9ECC5916, 0x9CEAA4C8, 0xC1A63EA7, 0x443FC117, 0xA31D8C8A, 0x2498625C, 0xB84FAEAD, 0xEAC9D729, 0x4BC07AE4, 0x8C6E9001, 0x48AC8FF5, 0x296B1E9A, 0x7B956FD7, 0x5C09D9AB, 0x6CD001CE, 0x4C0182A6, 0x8C72416F, 0x4FBAC405, 0x64AE9C5B, 0xCDA31800, 0x5D027F5D, 0xADB1D92C, 0x5B26D692, 0x1FAC90FE, 0x62BDD8B7, 0xD1695390, 0x3A012A35, 0xABFE394F, 0x8C0BF9AF, 0x770F07F2, 0xD4CB1377, 0x41D775C6, 0x1813E840, 0x51BA300A, 0xA6CF8505, 0xF3917847, 0x78FF2E73, 0x4B954AB9, 0x41536DC8, 0xA7AD5DF6, 0x1FA56E81, 0x109734B2, 0xA3A4B580, 0x407FA9B4, 0x3B9C8C71, 0x48EB928E, 0x2C29626B, 0x309E6FDF, 0xDBDC172D, 0x4DBA483A, 0x67BF0C49, 0xC86F5BCE, 0xB9AEB11E, 0xD3CD6097, 0x7701A3C2, 0x6BC1629F, 0x18DAB43, 0x91F80AA3, 0xAD12A904, 0x13B4CE5D, 0xD625FEB2, 0xF49897F1, 0x604BE0E4, 0x398A4E4F, 0x1E83D573, 0xA210B22A, 0x460D8E8E, 0x374C1DD, 0xC07E6F71, 0x3BDC2EDB, 0x709F7799, 0x71422D13, 0x87736CAA, 0x59AC736E, 0x658018E6, 0xFA9E136A, 0x97DFD90D, 0xCD9DB70D, 0x9F4C376E, 0x9C4F5693, 0x6575D472, 0xA5941E4D, 0x8ADE6293, 0xF897E736, 0x7F4AA491, 0x721335EB, 0xED0B95C7, 0x6364980F, 0xC97592C6, 0x469554E0, 0xA081B2E, 0x6430F976, 0x99FB41DB, 0x69C979A3, 0x4A7B198, 0xFB05D9A5, 0x541A25E4, 0x5E770D9D, 0xBB1315A2, 0xF7E8FA8F, 0xAF6C2A59, 0x9E433AC0, 0x6526D233, 0xED058E7A, 0x3CAD08A1, 0x966E88E6, 0x26FE790B, 0x3FBBE519, 0x757689F7, 0x69A866E4, 0x83B7B2E8, 0xEE698471, 0xD031A792, 0xD519D7CE, 0xF27D87F1, 0xF54AC75E};
static const int myrandomness_B[] = {0x5ED09BCE, 0xC058C2EF, 0xBFC563D6, 0x792C3772, 0x1CBF1960, 0x60956FC0, 0xB077DF3, 0x39F05306, 0xFAB76137, 0xA9F4BFCE, 0xEC0D48E3, 0xD967026C, 0x1C12C088, 0x391F9A94, 0xAAA1C88C, 0xC16EEC75, 0xF084FBA2, 0x67B96917, 0x106BD77D, 0x23DF6D16, 0x48BB6094, 0x1784416D, 0xA02702B2, 0x81678054, 0x84CF56D4, 0x55DB1855, 0xB183C632, 0x4B46D6B8, 0x75E01325, 0x9BDDEBA, 0xF4084C53, 0xAEBF75AB, 0xA0FB0B0E, 0x3E1D677D, 0xC65DE5B5, 0x36B30DAD, 0x52AC3966, 0xFD669873, 0xD973DAA9, 0x78EF2163, 0xE789724C, 0x3997E1BD, 0x6D3DF8D7, 0xCE5217FE, 0xE3E6D213, 0x748088D5, 0x13156F7, 0xA62677C0, 0x455EA1C2, 0x8B4F6968, 0x2D02D7A2, 0x4FE82E48, 0x2D87A5EB, 0x684667A6, 0x17C85786, 0x3548A833, 0x5C07796D, 0x77B1CEFD, 0xEB1914F9, 0xB3DDF313, 0xD5F393AB, 0xC4745B54, 0x1FCAD79, 0x1355F237, 0x1E9B700C, 0xD6858795, 0x3B06D543, 0xDE8C22C, 0x8773E559, 0x4FAB4571, 0x4EAF954A, 0xCED5B779, 0x55C0A32B, 0x75CFC445, 0xEBE16188, 0xD39A6369, 0xC59C504A, 0xEB6B3C00, 0x7C6AC15F, 0x85338413, 0xD46B2FD9, 0x40BA0154, 0x12976498, 0x54E05330, 0xA9DB48B3, 0xFAB03812, 0xEB098654, 0x4B597D22, 0xA74FF9CA, 0x1E7DBFD, 0xC0E99E77, 0xBD00A20A, 0xFD87E5E6, 0x15B53B47, 0xF9E1D0B3, 0x1307EC65, 0x81F777E3, 0xDB30B228, 0xD9C46A69, 0xA26ABD4B, 0x2A1E51E6, 0x26B5F719, 0x174F2E22, 0x92C4E63D, 0x254ED7AA, 0x53A10ADB, 0x26F75277, 0xC792EE35, 0xD03DE474, 0x297EBE85, 0xA9868A42, 0xC5B7D3D8, 0x42036C35, 0xF57EF054, 0x5AC3B4EE, 0xA4FB396, 0x9765DD39, 0xC15D34, 0x3647C035, 0xFE3E325E, 0x3801434, 0xAC6CF808, 0x9FA43C63, 0x5C80E9D3, 0xD8EB9D3F, 0x1DB5F54B, 0x7BA1ACB4, 0x6FC78A82, 0xAFCE331A, 0x89368504, 0xC00F65C6, 0x4BBD7B58, 0x62E7D766, 0x869CCD7D, 0xD8F7F8BA, 0x63C57382, 0x93466D8A, 0xE5CCB372, 0xF2F57254, 0xDB54889C, 0x4BAC6F9E, 0x6F606042, 0x3AAE16B1, 0xA17BDEF7, 0x1F504235, 0x6C6990FF, 0xAA3CD51F, 0x3237589A, 0xF89056C5, 0xFE0BEAD1, 0x59EFE1CC, 0xBC76C033, 0xA1DAA47E, 0x35434ADA, 0x9E858E11, 0x3C5280BE, 0x9B85B7F1, 0x315182DD, 0x78144F2B, 0xCD6E3C05, 0x26371BB, 0x22F43C5D, 0xD9C005C, 0x69747D, 0xBD95E023, 0xBF1DA56A, 0x94F513EB, 0x2181E155, 0x51BA9A39, 0xD0142CA4, 0x9CC5942, 0xC8CD2D95, 0x4220155E, 0x19C26CB4, 0xEE9F9944, 0xB058A80E, 0xBF2F1774, 0x35F74A7B, 0xF9BF8AC0, 0x9175CE92, 0x180AF233, 0x9592D3A9, 0xC88162B7, 0xDFB104E6, 0x1DE53107, 0x3DDB69F5, 0x7AD798, 0xAEB0515A, 0x3C5FF81D, 0x73343C3C, 0xA99D4F4D, 0x73BB5E52, 0x560E5844, 0x72057CC7, 0x4F993482, 0x65121FFA, 0x7980986E, 0xA0744038, 0xC85E9F26, 0x52B114F4, 0xDC952DE3, 0xDF22068D, 0x9CCB645E, 0x6D4A852B, 0xBF9DF43F, 0xCD05E5EC, 0xEB0BAC86, 0x81D491B8, 0xD2D25A24, 0x7B4A8E3, 0x15D947A4, 0x417DA7EB, 0xE8CC516E, 0xCEA63BF8, 0x79CB4A44, 0x3C455CBC, 0x5E9F821D, 0x2B0EEBC0, 0xCF38C691, 0x2D4DA03B, 0x5970C3E0, 0x94A76BB5, 0x7A33532, 0xB06236C5, 0xFBA4F2CD, 0xDC8AF564, 0xC8A5EB1, 0xAC9509FC, 0xF8CCE70B, 0x15B38FE8, 0x61E555E, 0x9E717596, 0x3802C9DF, 0x71F0F574, 0x30378B7D, 0x527CB53E, 0x1C80108F, 0x38FF9F93, 0x6D2F03A4, 0x6C83E39D, 0x3B8CA0B1, 0xD336B96C, 0xA0F81C27, 0x8B18C474, 0x643B29D, 0x321A04FB, 0xD6D19A06, 0x5BCA6A0C, 0xFE9AA60C, 0x2242ABF3, 0x6810F9A, 0xDBF645BA, 0xAB4EA421, 0x638BCAF0, 0x660C119B, 0xCAF38A74, 0x5F78C0D8, 0x89F59E0C, 0x99D87C43, 0x793CB0F7, 0x44BB452F, 0x5C269412, 0x851A8BF4, 0x3A27F476, 0xD425A62D, 0x647A07C4, 0xBCD4A43C, 0xF59AE7AA, 0x91706ED9, 0xC98B9052, 0x52581557, 0x726593C3, 0x47709046, 0xFD2DBBEB, 0x474AAFCA, 0x88E80434, 0x902A98B9, 0x19D65310, 0x9B4AE779, 0x41961C80, 0xD52E5522, 0x1C3DCFBF, 0xCD399F87, 0xFE8DC343, 0x6742A195, 0x4BD3BABB, 0x8EBC55C7, 0x74DA448D, 0x6A8F304E, 0xE6DF9F55, 0x3C1769C6, 0x32C564E1, 0xC4AD9EC3, 0x9E7D4081, 0x2165CB46, 0x14020E27, 0x574B8A2C, 0x4C77B209, 0xF2861D8, 0x91CCA89F, 0x6B5F2B47, 0x81DEE1A9, 0x7ECD5302, 0xA70037D4, 0x24D04815, 0xA26F899F, 0xE0A982E4, 0x7B0225B9, 0x856103BD, 0xA37E4C59, 0x371E28DE, 0xFD199210, 0xD86D735C, 0x6A4BB8A0, 0xBF3C7865, 0x215EDA87, 0x248197E5, 0x4AAA9070, 0xC56A1540, 0x20C4E642, 0x922DCA04, 0xE2CAC179, 0x3CEEE19C, 0xA7F2E857, 0xA6B0E874, 0xA6042D4C, 0xCAA0BB0C, 0x84E09A83, 0xD0967394, 0xB98BE741, 0xB68744B2, 0x95FA9C27, 0x2D8277AE, 0xA6D57336, 0xB82C4E22, 0xC6B608, 0x1875EFAF, 0xA5757BAB, 0xC69BA3F2, 0xA5A27376, 0xCDCF79CE, 0xAB7B66C7, 0x65578DAF, 0x4D6D404D, 0x375F1A9D, 0xBD95D445, 0xC8E2DB09, 0xD595043E, 0xDC3D02FE, 0x2E928093, 0xF268EC3E, 0xDC9A0E48, 0x66D58387, 0xBF2386AE, 0xB53C0A07, 0xC1546070, 0xC7066285, 0x3AB658E5, 0x2A9739FE, 0x231E82C8, 0x7706F158, 0x400E5062, 0x8FA866CD, 0x9AD9F2A, 0x72085D5E, 0xB5F7F31F, 0xB663992B, 0x7B36D511, 0xF0D96F1D, 0xF2058DB4, 0x35DA8E03, 0x1D5AB8D6, 0xFD5732D2, 0xB176B798, 0x6D28E26E, 0x1A1FD567, 0x982FBFBB, 0xFDD37FBF, 0x5095F113, 0x2590F34D, 0xFCA47388, 0xA6C04883, 0x126C3313, 0xDF0BB55E, 0xF2A6A964, 0x6CDB2970, 0x46B643E8, 0x1889AEBE, 0x428BA57A, 0xA5F5FA47, 0xD59C994D, 0xB47FDD62, 0xC357B07B, 0xEF660114, 0x9481753C, 0x5F821557, 0xBAB2DEA2, 0x43766096, 0x28688420, 0x34C3AA8, 0xACFF1845, 0xA607A90F, 0xE7A1EFCE, 0x434C661D, 0x4233A02D, 0x9B2D9C3E, 0x531E1B71, 0x2C16FCBC, 0x72B6B402, 0xE943DF2A, 0x12AF22CB, 0x555A775, 0x134592D7, 0x9CFB5889, 0xAF4FC11E, 0x207EF941, 0xF1D1826F, 0xFF2E9BD0, 0x44E1390, 0x82524F5B, 0x9622DF64, 0x699038E3, 0x999C4D3B, 0xEB6DBDC3, 0x585F1E93, 0x24057A9, 0xC2A78338, 0x1AF22336, 0xB4FEF545, 0xAA4E31A3, 0xD059532C, 0x6230BE55, 0x2C2DCF01, 0xF8971E75, 0xEE26C1DB, 0x35712F58, 0x85EC0448, 0xA000089F, 0xBA5E5BC7, 0xE3763DD6, 0xBC0CF35E, 0xC210A5A0, 0xE1FD2023, 0x55ED8D5E, 0x9E098FD5, 0x1589F159, 0x3F6C595, 0xB922E9CD, 0x9FB9ED37, 0x9C7F6FA5, 0x8F86B155, 0x422BC552, 0x8D59667F, 0xCAAD15E8, 0x4A000782, 0x6414EEA7, 0xC7930AF4, 0xF7F298D0, 0x8A63F2C1, 0x3E37295D, 0x21875EFC, 0x406970E2, 0x2F7E8F3B, 0x276DC533, 0x4E8E0A1B, 0xCE099259, 0x1E1EB703, 0x95A9A0D5, 0x633EA087, 0xD9697DCF, 0xC09020FF, 0xF334BA14, 0xE2246074, 0xE731CE21, 0x8FAA964, 0x1E6F2B2C, 0xA5900AA4, 0xEA0DCAFC, 0xD03197A1, 0xBF332823, 0xA0791382, 0xEC0B6D47, 0xA206BB54, 0x26BEE3E0, 0x413B0B95, 0x7469AB1F, 0x5585A293, 0x3E048D48, 0x67712854, 0x3F8CB8B2, 0xD08A7B44, 0x9675415A, 0x1A289B91, 0x39908E5C, 0x5A1A4F76, 0x94207D4, 0x764D645F, 0x38899654, 0xBFDD4488, 0x13E1B925, 0x28032C0B, 0x55AEBD34, 0x7B337CC1, 0xB78F05EF, 0xF03FD644, 0x832A48D4, 0x7C5D2998, 0x57843A6, 0x9A8E555D, 0x86D5E09B, 0x8C22C21F, 0x93BE1A7A, 0xC4B60FF3, 0x54EBF6B7, 0xA8BB01EA, 0x5A886D10, 0xE1F6D65F, 0x38CD173, 0xC78D4A38, 0xB7E4DE0F, 0xC6A81DB1, 0x163DBE07, 0x4A8AEDB3, 0xDF2AE25F, 0x92F931D0, 0xC336C31B, 0x7F2DF263, 0xA007D73F, 0x56F4BC43, 0x10340776, 0xD8772E77, 0xDC9C12BB, 0x1E95D0F5, 0xB1F7349C, 0x7A4C9EEB, 0xB7205F41, 0xB25648FA, 0x6A90406B, 0x804AF4E8, 0xCE9BE5C9, 0x4E13BDA4, 0x72B49F90, 0x6E66C892, 0xD2F29D4C, 0xD142D2E2, 0xD3813FA, 0xEB1F62A2, 0x1B2FE313, 0x2F66CABA, 0xF442B093, 0x97964824, 0x7E12FA45, 0xB0DE6FC8, 0xBE95C22D, 0x71E77D53, 0x57ED8125, 0x4C6B8575, 0xFDA28023, 0xCD6420AC, 0xF33C96F0, 0xB51793, 0x44BB8417, 0x70097937, 0x74E125EA, 0x517C22AB, 0x182C8523, 0x6F33C086, 0x4DB668A6, 0x9243E927, 0x1D1B628D, 0x64506E66, 0x3A987BCE, 0xACE5B914, 0xFC6B796, 0xC0F41DA6, 0x4EBEF795, 0x27ED5E92, 0xBF667BF9, 0x7F743E25, 0x931CB9B6, 0x2F39F1D8, 0x7B7F65F5, 0xE85A8E72, 0x328BF287, 0x689A8192, 0x5AA51C7F, 0xC2FD6F3C, 0xE74CF344, 0x4FFA7A25, 0x35636A49, 0xEEA2B9B3, 0x867BCEE0, 0xE47A8C20, 0xCB9994EB, 0x67A0A23D, 0x50E6AC89, 0x53BE1A6B, 0xECA546AF, 0x4EF8BA87, 0x1783F941, 0x74D875D5, 0xED834BAC, 0xD98252F2, 0x708DA8E8, 0xC2B543AF, 0x1706017, 0x5B514720, 0x55C241B0, 0xAA729C3F, 0x1A2266FE, 0xC3F310E3, 0x2D425A29, 0x1E07ECD8, 0xDBFD7323, 0x48F27C99, 0x68ADBEDE, 0x1D463CFD, 0xFCA3AFB2, 0x76848F3A, 0x1DAD4990, 0xE010FA4C, 0x65DAECCE, 0x4BA06800, 0x8E09392, 0x9BC28BAD, 0x4C5B5A25, 0xB56A865B, 0x5BFCF0B2, 0xDC72E70C, 0x1EBC1BC0, 0xA2122FF1, 0x73F91236, 0xC1D056C1, 0xA1502E5C, 0x4B5330B6, 0xF3490EF2, 0xD62371D4, 0xB360169C, 0x7FA07467, 0x8B6D909D, 0x2E0D5633, 0x47A7B282, 0x85192DBD, 0xF3D86568, 0xB860FE76, 0xCD81F5BF, 0x6F021117, 0x35E5CE96, 0x15008FAF, 0x6656E7BA, 0xFBA14D04, 0x6D9FC71E, 0xCC750348, 0x76F83AB8, 0x48334C43, 0x54EE1C5A, 0xCC4BF4E2, 0xDBA38AF6, 0x203AA383, 0xAEC52ED2, 0x1FE60A12, 0x7472B5A1, 0x5A22F00A, 0x39A094B9, 0xD0F6ECBA, 0x81DB81AD, 0x59F05F42, 0xD3F9F92D, 0x6E96F44C, 0x2D9451B, 0xA343366A, 0xA85455EC, 0x8CF26537, 0x672F2A7F, 0x864B87BA, 0xB0E5377C, 0x53741F50, 0xC2DB90C9, 0x1F6E0FCA, 0x62267802, 0xE297DAF6, 0xB7634865, 0x47AB2E74, 0xBDF2FBF1, 0xA9A355F, 0x6C7E09A9, 0xF40FA3AB, 0x8906F82B, 0xE99A2EA3, 0xC26F4B40, 0x300B08CF, 0x359516F9, 0xA6585615, 0x8388060B, 0x2B057449, 0x5E029D10, 0xFC003CD2, 0x4DEAB774, 0x1A3A49F5, 0x1A4BB592, 0x77D07641, 0x486A791F, 0x1F908F4, 0xDDF59176, 0xE8ECB210, 0xF1F2EBD8, 0x3BE8A0D1, 0xCCB9A840, 0x1F2F0C01, 0xF4A93515, 0xDB5DD22A, 0xE2DFC943, 0x872DCD07, 0xC50BB9AD, 0xE75006CA, 0xDE9A41E5, 0xDF4C666A, 0x879679AB, 0xB65A603A, 0xA98634D3, 0x7226A211, 0x99B58DC8, 0x8E366CF6, 0x42CAAFCF, 0x4D719B9C, 0x3EEEAA55, 0x5266D89C, 0x4B55B81D, 0xB6281487, 0xA1AA9E44, 0x9EE82139, 0x3F46A865, 0xF5823A46, 0x19C1397E, 0x744F21A9, 0x858696A4, 0xB86B3A66, 0x25544F6A, 0x94174BB8, 0xDF1AC7D9, 0xA3E2A4BA, 0x42D2A581, 0x178ABB7E, 0x56D78B60, 0x95552453, 0xAA3C8750, 0x15F7C747, 0x9AE6F8A6, 0x64E26DC9, 0x76EFB034, 0x552DA6D7, 0x1B9C7172, 0x20955D1B, 0xABC2148F, 0xF884AF7A, 0xF7799F5, 0x78D0771D, 0x5DDB009A, 0x707737EB, 0x484D2865, 0xA030415, 0x7AD837EA, 0x5135BC52, 0xD21BD1BC, 0xF64DE4A9, 0x17A13E75, 0x6AAD6332, 0x149F8BDF, 0x1FBDB5C7, 0xE017B743, 0xAB82F5DD, 0xDC714529, 0xEA988A13, 0x8A56B17C, 0x42C09EC1, 0x53CDD0B, 0xCC8B236E, 0x15489341, 0xB034D5A2, 0x57053984, 0xDBA9DBEB, 0x8E87CA6F, 0xC3D35340, 0x99F1ACC8, 0x8AA41123, 0x15A10948, 0xE7240CC4, 0x9AD0030F, 0x886399FE, 0xF46737E5, 0xE461F70A, 0x9A9A44F7, 0x28C4D000, 0x39BB5A71, 0x8FDEEB5A, 0xEF2596D5, 0xAACDC9AC, 0xE74903, 0xE7BD0817, 0x16AFD8EF, 0xC9E7F615, 0xA2A89ECF, 0x29753AA1, 0x3567EC6B, 0x7562A786, 0x6E736191, 0xE2EF66AD, 0x154200F8, 0x9D2F6ABD, 0x58C0519B, 0x54BFAE73, 0xA52072E7, 0x2EF4BACD, 0xBB402506, 0x18770A1A, 0xE55E89F2, 0xC8D7A2, 0x2FB70D1, 0xCC97EE7D, 0x8CD35C9A, 0xADA051BC, 0x70BAEE2B, 0x38833748, 0x16302E20, 0xC0565D28, 0xB6975F09, 0x9640997E, 0x38605A9B, 0x9CF84593, 0x31B39D72, 0xB023B2D4, 0x1803E7C5, 0x32A8AA26, 0xC719C4FD, 0x5A51EE83, 0x14A35812, 0x257909B0, 0xDF9C906F, 0x3FAD700, 0x1B8D23DF, 0xE6356CC7, 0x3F023E92, 0x31BF97C7, 0x4B26DD96, 0x1706854B, 0x5D38B73D, 0x8FA37C88, 0xABF80962, 0xEAE34192, 0x73A6ADF1, 0x78831576, 0xDBDF0BDE, 0x408C4F5B, 0xCC1AFCE0, 0xB13A9F66, 0x31A5CC32, 0x83F09FD4, 0x16B36629, 0x47D9DA6E, 0xC7242780, 0x5113CAC2, 0x5A14BCF2, 0x91503AC0, 0x8A3FD484, 0x85307E71, 0x454EAED0, 0x18F8AB98, 0x59E3A069, 0xB10EE27, 0xEEBA9ECD, 0xCB5D5136, 0xF62D5E37, 0xE04F633B, 0xCEE6042D, 0x767274FC, 0x63429107, 0x4EDFD39A, 0x47A02713, 0x168F36A9, 0x9599580, 0xBB5EC19B, 0x9D158765, 0xFEC87FBA, 0x89DF2762, 0x91897004, 0x3988FDA6, 0xE5CED34F, 0x55662D7D, 0x2A44508, 0xE70DB26F, 0x1BFA4DF6, 0x597AA4D6, 0xF8E1A55, 0x7CD3D320, 0x10831BEF, 0x8607BF7A, 0x84C9BD0D, 0x33E81D7F, 0x89742F0, 0x2D0E6A29, 0x5D983371, 0xD21FB666, 0xD86BC388, 0x474FF8AC, 0xC2209801, 0x80683284, 0x4E3915D3, 0x5AAC99BE, 0x17BEED9E, 0x6B1B828A, 0x172CED31, 0x98DC76CB, 0x1B113A68, 0x8C5E78BF, 0x92852795, 0x6B4BCB6, 0xD667C4B, 0xE192C8E9, 0x79EBDB38, 0xEEDB6C92, 0xEB9DBE74, 0x31153A7D, 0x14E0D0DF, 0xFB90C1A3, 0x9FAA1E0F, 0xC3870A11, 0x6F753F20, 0xD882BA4C, 0x44DAC402, 0xB7F691C2, 0xD9FDDE26, 0x33319BB8, 0xF1EABDFF, 0x6AAA15F, 0xB50DE68A, 0xE4D218E0, 0x896504D, 0xFEDDB45D, 0x3DFD7AF9, 0x81801CB2, 0xD1F329D, 0x4306FFD9, 0x536B9137, 0xBBFB763A, 0xEE5D8DB6, 0x79AFEC5B, 0xFFB5F7B4, 0x2BF6CB30, 0xF9307150, 0x3B4AC1D6, 0xEC6D91D3, 0x9B113219, 0x9218F37A, 0xA1FE0A44, 0x18D62526, 0x2BA4A0EE, 0xF5E35F7A, 0x9CEFDDE8, 0x4DE21C0C, 0x5B9A88E, 0xE86A3AC, 0x78C74FDA, 0x4E5215B2, 0xA19A5280, 0x9D395167, 0xAF0BCA8B, 0x2E990354, 0x15E97CBE, 0x349B6ADD, 0xA7E09B2A, 0xE5D00F60, 0x41FE2EAD, 0xE6DD8F50, 0x2657A620, 0x565C04D1, 0xFC5F62F6, 0x1891CE51, 0xB51E1E78, 0xBE3869CC, 0x7833182B, 0xE10458DD, 0xAB5D3B8A, 0x2D28C4F1, 0xC28C293A, 0xF7DBADA0, 0xD5A34151, 0x1BD1A73, 0xEDCB201D, 0xE0C18857, 0xF01D0F37, 0xD761BFB5, 0x4FD2F679, 0x7B3237A9, 0x3E67B4B8, 0xD7CD58B5, 0x3B07081E, 0x30F67A76, 0x41F26F89, 0xE24EDC45, 0x3EB49CD9, 0xA7CC2D32, 0x8EF9DC1C, 0xB83CB6C9, 0xECACF51, 0xF92E4989, 0x9838FB64, 0x52C71A04, 0xAAA53639, 0x6FD53F9E, 0xBFF8311E, 0x2CBF3E4A, 0x62FABAF9, 0xA69617E3, 0x33FC3D6D, 0xF72AEDAF, 0xC7555B85, 0x7FFA3A24, 0xA255453C, 0xFBA7DC62, 0x75B92DB2, 0x43BCA072, 0x8A1E59CA, 0xAF3B66A1, 0x5360B7BE, 0x56FF762F, 0xF65A396, 0xD57709BC, 0x6E5AE893, 0x4B1BE30E, 0xAA3CE421, 0xF8C5FB0E, 0x9E422D57, 0x312B1233, 0x8537F509, 0x4328BADA, 0x913F25A3, 0xE7022C19, 0xE4FC60F8, 0x47A9F1D4, 0xD40329DF, 0xE109D606, 0x8B69F6D9, 0xBD24DF92, 0xDA0E32AD, 0xFEE5184E, 0xA166BEA5, 0xDC9CE395, 0x3F2342D4, 0x2697EDB7, 0xE152117F, 0x6D528AA0, 0x90CB448E, 0xBFFC45C3, 0x42BAC2FE, 0x5A62F7A, 0x9657EF5B, 0x537E3592, 0x9E8586A7, 0x72A2EA74, 0xA66F875F, 0x1E41EB3B, 0x18AA4B97, 0x62104FE9, 0x1A4F4AA2, 0xBA5618FC, 0x281C285D, 0x6429B69A, 0x78280AE7, 0x8E481173, 0x48A4E5F9, 0xBE5B1704, 0x9CB10444, 0x4EDED269, 0xBDBF6411, 0xBDAE246, 0x8FE6C248, 0x876DE5C, 0xEF34385, 0x8D65DC0F, 0xCBAFF208, 0x48BB4374, 0xC49510E7, 0xA2AC0E7, 0xBE00B389, 0xDB744D76, 0xB4BAC272, 0x403C5D1};

static atomic_t myrandomness_pos = ATOMIC_INIT(152161);

//EDIT:END


/*
 * If the entropy count falls under this number of bits, then we
 * should wake up processes which are selecting or polling on write
 * access to /dev/random.
 */
static int random_write_wakeup_bits = 28 * OUTPUT_POOL_WORDS;

/*
 * Originally, we used a primitive polynomial of degree .poolwords
 * over GF(2).  The taps for various sizes are defined below.  They
 * were chosen to be evenly spaced except for the last tap, which is 1
 * to get the twisting happening as fast as possible.
 *
 * For the purposes of better mixing, we use the CRC-32 polynomial as
 * well to make a (modified) twisted Generalized Feedback Shift
 * Register.  (See M. Matsumoto & Y. Kurita, 1992.  Twisted GFSR
 * generators.  ACM Transactions on Modeling and Computer Simulation
 * 2(3):179-194.  Also see M. Matsumoto & Y. Kurita, 1994.  Twisted
 * GFSR generators II.  ACM Transactions on Modeling and Computer
 * Simulation 4:254-266)
 *
 * Thanks to Colin Plumb for suggesting this.
 *
 * The mixing operation is much less sensitive than the output hash,
 * where we use SHA-1.  All that we want of mixing operation is that
 * it be a good non-cryptographic hash; i.e. it not produce collisions
 * when fed "random" data of the sort we expect to see.  As long as
 * the pool state differs for different inputs, we have preserved the
 * input entropy and done a good job.  The fact that an intelligent
 * attacker can construct inputs that will produce controlled
 * alterations to the pool's state is not important because we don't
 * consider such inputs to contribute any randomness.  The only
 * property we need with respect to them is that the attacker can't
 * increase his/her knowledge of the pool's state.  Since all
 * additions are reversible (knowing the final state and the input,
 * you can reconstruct the initial state), if an attacker has any
 * uncertainty about the initial state, he/she can only shuffle that
 * uncertainty about, but never cause any collisions (which would
 * decrease the uncertainty).
 *
 * Our mixing functions were analyzed by Lacharme, Roeck, Strubel, and
 * Videau in their paper, "The Linux Pseudorandom Number Generator
 * Revisited" (see: http://eprint.iacr.org/2012/251.pdf).  In their
 * paper, they point out that we are not using a true Twisted GFSR,
 * since Matsumoto & Kurita used a trinomial feedback polynomial (that
 * is, with only three taps, instead of the six that we are using).
 * As a result, the resulting polynomial is neither primitive nor
 * irreducible, and hence does not have a maximal period over
 * GF(2**32).  They suggest a slight change to the generator
 * polynomial which improves the resulting TGFSR polynomial to be
 * irreducible, which we have made here.
 */
static struct poolinfo {
	int poolbitshift, poolwords, poolbytes, poolbits, poolfracbits;
#define S(x) ilog2(x)+5, (x), (x)*4, (x)*32, (x) << (ENTROPY_SHIFT+5)
	int tap1, tap2, tap3, tap4, tap5;
} poolinfo_table[] = {
	/* was: x^128 + x^103 + x^76 + x^51 +x^25 + x + 1 */
	/* x^128 + x^104 + x^76 + x^51 +x^25 + x + 1 */
	{ S(128),	104,	76,	51,	25,	1 },
	/* was: x^32 + x^26 + x^20 + x^14 + x^7 + x + 1 */
	/* x^32 + x^26 + x^19 + x^14 + x^7 + x + 1 */
	{ S(32),	26,	19,	14,	7,	1 },
#if 0
	/* x^2048 + x^1638 + x^1231 + x^819 + x^411 + x + 1  -- 115 */
	{ S(2048),	1638,	1231,	819,	411,	1 },

	/* x^1024 + x^817 + x^615 + x^412 + x^204 + x + 1 -- 290 */
	{ S(1024),	817,	615,	412,	204,	1 },

	/* x^1024 + x^819 + x^616 + x^410 + x^207 + x^2 + 1 -- 115 */
	{ S(1024),	819,	616,	410,	207,	2 },

	/* x^512 + x^411 + x^308 + x^208 + x^104 + x + 1 -- 225 */
	{ S(512),	411,	308,	208,	104,	1 },

	/* x^512 + x^409 + x^307 + x^206 + x^102 + x^2 + 1 -- 95 */
	{ S(512),	409,	307,	206,	102,	2 },
	/* x^512 + x^409 + x^309 + x^205 + x^103 + x^2 + 1 -- 95 */
	{ S(512),	409,	309,	205,	103,	2 },

	/* x^256 + x^205 + x^155 + x^101 + x^52 + x + 1 -- 125 */
	{ S(256),	205,	155,	101,	52,	1 },

	/* x^128 + x^103 + x^78 + x^51 + x^27 + x^2 + 1 -- 70 */
	{ S(128),	103,	78,	51,	27,	2 },

	/* x^64 + x^52 + x^39 + x^26 + x^14 + x + 1 -- 15 */
	{ S(64),	52,	39,	26,	14,	1 },
#endif
};

/*
 * Static global variables
 */
static DECLARE_WAIT_QUEUE_HEAD(random_read_wait);
static DECLARE_WAIT_QUEUE_HEAD(random_write_wait);
static struct fasync_struct *fasync;

static DEFINE_SPINLOCK(random_ready_list_lock);
static LIST_HEAD(random_ready_list);

struct crng_state {
	__u32		state[16];
	unsigned long	init_time;
	spinlock_t	lock;
};

struct crng_state primary_crng = {
	.lock = __SPIN_LOCK_UNLOCKED(primary_crng.lock),
};

/*
 * crng_init =  0 --> Uninitialized
 *		1 --> Initialized
 *		2 --> Initialized from input_pool
 *
 * crng_init is protected by primary_crng->lock, and only increases
 * its value (from 0->1->2).
 */
static int crng_init = 0;
#define crng_ready() (likely(crng_init > 1))
static int crng_init_cnt = 0;
static unsigned long crng_global_init_time = 0;
#define CRNG_INIT_CNT_THRESH (2*CHACHA20_KEY_SIZE)
static void _extract_crng(struct crng_state *crng,
			  __u8 out[CHACHA20_BLOCK_SIZE]);
static void _crng_backtrack_protect(struct crng_state *crng,
				    __u8 tmp[CHACHA20_BLOCK_SIZE], int used);
static void process_random_ready_list(void);
static void _get_random_bytes(void *buf, int nbytes);

static struct ratelimit_state unseeded_warning =
	RATELIMIT_STATE_INIT("warn_unseeded_randomness", HZ, 3);
static struct ratelimit_state urandom_warning =
	RATELIMIT_STATE_INIT("warn_urandom_randomness", HZ, 3);

static int ratelimit_disable __read_mostly;

module_param_named(ratelimit_disable, ratelimit_disable, int, 0644);
MODULE_PARM_DESC(ratelimit_disable, "Disable random ratelimit suppression");

/**********************************************************************
 *
 * OS independent entropy store.   Here are the functions which handle
 * storing entropy in an entropy pool.
 *
 **********************************************************************/

struct entropy_store;
struct entropy_store {
	/* read-only data: */
	const struct poolinfo *poolinfo;
	__u32 *pool;
	const char *name;
	struct entropy_store *pull;
	struct work_struct push_work;

	/* read-write data: */
	unsigned long last_pulled;
	spinlock_t lock;
	unsigned short add_ptr;
	unsigned short input_rotate;
	int entropy_count;
	int entropy_total;
	unsigned int initialized:1;
	unsigned int last_data_init:1;
	__u8 last_data[EXTRACT_SIZE];
};

static ssize_t extract_entropy(struct entropy_store *r, void *buf,
			       size_t nbytes, int min, int rsvd);
static ssize_t _extract_entropy(struct entropy_store *r, void *buf,
				size_t nbytes, int fips);

static void crng_reseed(struct crng_state *crng, struct entropy_store *r);
static void push_to_pool(struct work_struct *work);
static __u32 input_pool_data[INPUT_POOL_WORDS] __latent_entropy;
static __u32 blocking_pool_data[OUTPUT_POOL_WORDS] __latent_entropy;

static struct entropy_store input_pool = {
	.poolinfo = &poolinfo_table[0],
	.name = "input",
	.lock = __SPIN_LOCK_UNLOCKED(input_pool.lock),
	.pool = input_pool_data
};

static struct entropy_store blocking_pool = {
	.poolinfo = &poolinfo_table[1],
	.name = "blocking",
	.pull = &input_pool,
	.lock = __SPIN_LOCK_UNLOCKED(blocking_pool.lock),
	.pool = blocking_pool_data,
	.push_work = __WORK_INITIALIZER(blocking_pool.push_work,
					push_to_pool),
};

static __u32 const twist_table[8] = {
	0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,
	0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278 };

/*
 * This function adds bytes into the entropy "pool".  It does not
 * update the entropy estimate.  The caller should call
 * credit_entropy_bits if this is appropriate.
 *
 * The pool is stirred with a primitive polynomial of the appropriate
 * degree, and then twisted.  We twist by three bits at a time because
 * it's cheap to do so and helps slightly in the expected case where
 * the entropy is concentrated in the low-order bits.
 */
static void _mix_pool_bytes(struct entropy_store *r, const void *in,
			    int nbytes)
{
	unsigned long i, tap1, tap2, tap3, tap4, tap5;
	int input_rotate;
	int wordmask = r->poolinfo->poolwords - 1;
	const char *bytes = in;
	__u32 w;

	tap1 = r->poolinfo->tap1;
	tap2 = r->poolinfo->tap2;
	tap3 = r->poolinfo->tap3;
	tap4 = r->poolinfo->tap4;
	tap5 = r->poolinfo->tap5;

	input_rotate = r->input_rotate;
	i = r->add_ptr;

	/* mix one byte at a time to simplify size handling and churn faster */
	while (nbytes--) {
		w = rol32(*bytes++, input_rotate);
		i = (i - 1) & wordmask;

		/* XOR in the various taps */
		w ^= r->pool[i];
		w ^= r->pool[(i + tap1) & wordmask];
		w ^= r->pool[(i + tap2) & wordmask];
		w ^= r->pool[(i + tap3) & wordmask];
		w ^= r->pool[(i + tap4) & wordmask];
		w ^= r->pool[(i + tap5) & wordmask];

		/* Mix the result back in with a twist */
		r->pool[i] = (w >> 3) ^ twist_table[w & 7];

		/*
		 * Normally, we add 7 bits of rotation to the pool.
		 * At the beginning of the pool, add an extra 7 bits
		 * rotation, so that successive passes spread the
		 * input bits across the pool evenly.
		 */
		input_rotate = (input_rotate + (i ? 7 : 14)) & 31;
	}

	r->input_rotate = input_rotate;
	r->add_ptr = i;
}

static void __mix_pool_bytes(struct entropy_store *r, const void *in,
			     int nbytes)
{
	trace_mix_pool_bytes_nolock(r->name, nbytes, _RET_IP_);
	_mix_pool_bytes(r, in, nbytes);
}

static void mix_pool_bytes(struct entropy_store *r, const void *in,
			   int nbytes)
{
	unsigned long flags;

	trace_mix_pool_bytes(r->name, nbytes, _RET_IP_);
	spin_lock_irqsave(&r->lock, flags);
	_mix_pool_bytes(r, in, nbytes);
	spin_unlock_irqrestore(&r->lock, flags);
}

struct fast_pool {
	__u32		pool[4];
	unsigned long	last;
	unsigned short	reg_idx;
	unsigned char	count;
};

/*
 * This is a fast mixing routine used by the interrupt randomness
 * collector.  It's hardcoded for an 128 bit pool and assumes that any
 * locks that might be needed are taken by the caller.
 */
static void fast_mix(struct fast_pool *f)
{
	__u32 a = f->pool[0],	b = f->pool[1];
	__u32 c = f->pool[2],	d = f->pool[3];

	a += b;			c += d;
	b = rol32(b, 6);	d = rol32(d, 27);
	d ^= a;			b ^= c;

	a += b;			c += d;
	b = rol32(b, 16);	d = rol32(d, 14);
	d ^= a;			b ^= c;

	a += b;			c += d;
	b = rol32(b, 6);	d = rol32(d, 27);
	d ^= a;			b ^= c;

	a += b;			c += d;
	b = rol32(b, 16);	d = rol32(d, 14);
	d ^= a;			b ^= c;

	f->pool[0] = a;  f->pool[1] = b;
	f->pool[2] = c;  f->pool[3] = d;
	f->count++;
}

static void process_random_ready_list(void)
{
	unsigned long flags;
	struct random_ready_callback *rdy, *tmp;

	spin_lock_irqsave(&random_ready_list_lock, flags);
	list_for_each_entry_safe(rdy, tmp, &random_ready_list, list) {
		struct module *owner = rdy->owner;

		list_del_init(&rdy->list);
		rdy->func(rdy);
		module_put(owner);
	}
	spin_unlock_irqrestore(&random_ready_list_lock, flags);
}

/*
 * Credit (or debit) the entropy store with n bits of entropy.
 * Use credit_entropy_bits_safe() if the value comes from userspace
 * or otherwise should be checked for extreme values.
 */
static void credit_entropy_bits(struct entropy_store *r, int nbits)
{
	int entropy_count, orig;
	const int pool_size = r->poolinfo->poolfracbits;
	int nfrac = nbits << ENTROPY_SHIFT;

	if (!nbits)
		return;

retry:
	entropy_count = orig = ACCESS_ONCE(r->entropy_count);
	if (nfrac < 0) {
		/* Debit */
		entropy_count += nfrac;
	} else {
		/*
		 * Credit: we have to account for the possibility of
		 * overwriting already present entropy.	 Even in the
		 * ideal case of pure Shannon entropy, new contributions
		 * approach the full value asymptotically:
		 *
		 * entropy <- entropy + (pool_size - entropy) *
		 *	(1 - exp(-add_entropy/pool_size))
		 *
		 * For add_entropy <= pool_size/2 then
		 * (1 - exp(-add_entropy/pool_size)) >=
		 *    (add_entropy/pool_size)*0.7869...
		 * so we can approximate the exponential with
		 * 3/4*add_entropy/pool_size and still be on the
		 * safe side by adding at most pool_size/2 at a time.
		 *
		 * The use of pool_size-2 in the while statement is to
		 * prevent rounding artifacts from making the loop
		 * arbitrarily long; this limits the loop to log2(pool_size)*2
		 * turns no matter how large nbits is.
		 */
		int pnfrac = nfrac;
		const int s = r->poolinfo->poolbitshift + ENTROPY_SHIFT + 2;
		/* The +2 corresponds to the /4 in the denominator */

		do {
			unsigned int anfrac = min(pnfrac, pool_size/2);
			unsigned int add =
				((pool_size - entropy_count)*anfrac*3) >> s;

			entropy_count += add;
			pnfrac -= anfrac;
		} while (unlikely(entropy_count < pool_size-2 && pnfrac));
	}

	if (unlikely(entropy_count < 0)) {
		pr_warn("random: negative entropy/overflow: pool %s count %d\n",
			r->name, entropy_count);
		WARN_ON(1);
		entropy_count = 0;
	} else if (entropy_count > pool_size)
		entropy_count = pool_size;
	if (cmpxchg(&r->entropy_count, orig, entropy_count) != orig)
		goto retry;

	r->entropy_total += nbits;
	if (!r->initialized && r->entropy_total > 128) {
		r->initialized = 1;
		r->entropy_total = 0;
	}

	trace_credit_entropy_bits(r->name, nbits,
				  entropy_count >> ENTROPY_SHIFT,
				  r->entropy_total, _RET_IP_);

	if (r == &input_pool) {
		int entropy_bits = entropy_count >> ENTROPY_SHIFT;

		if (crng_init < 2 && entropy_bits >= 128) {
			crng_reseed(&primary_crng, r);
			entropy_bits = r->entropy_count >> ENTROPY_SHIFT;
		}

		/* should we wake readers? */
		if (entropy_bits >= random_read_wakeup_bits) {
			wake_up_interruptible(&random_read_wait);
			kill_fasync(&fasync, SIGIO, POLL_IN);
		}
		/* If the input pool is getting full, send some
		 * entropy to the blocking pool until it is 75% full.
		 */
		if (entropy_bits > random_write_wakeup_bits &&
		    r->initialized &&
		    r->entropy_total >= 2*random_read_wakeup_bits) {
			struct entropy_store *other = &blocking_pool;

			if (other->entropy_count <=
			    3 * other->poolinfo->poolfracbits / 4) {
				schedule_work(&other->push_work);
				r->entropy_total = 0;
			}
		}
	}
}

static int credit_entropy_bits_safe(struct entropy_store *r, int nbits)
{
	const int nbits_max = r->poolinfo->poolwords * 32;

	if (nbits < 0)
		return -EINVAL;

	/* Cap the value to avoid overflows */
	nbits = min(nbits,  nbits_max);

	credit_entropy_bits(r, nbits);
	return 0;
}

/*********************************************************************
 *
 * CRNG using CHACHA20
 *
 *********************************************************************/

#define CRNG_RESEED_INTERVAL (300*HZ)

static DECLARE_WAIT_QUEUE_HEAD(crng_init_wait);

#ifdef CONFIG_NUMA
/*
 * Hack to deal with crazy userspace progams when they are all trying
 * to access /dev/urandom in parallel.  The programs are almost
 * certainly doing something terribly wrong, but we'll work around
 * their brain damage.
 */
static struct crng_state **crng_node_pool __read_mostly;
#endif

static void invalidate_batched_entropy(void);

static void crng_initialize(struct crng_state *crng)
{
	int		i;
	unsigned long	rv;

	memcpy(&crng->state[0], "expand 32-byte k", 16);
	if (crng == &primary_crng)
		_extract_entropy(&input_pool, &crng->state[4],
				 sizeof(__u32) * 12, 0);
	else
		_get_random_bytes(&crng->state[4], sizeof(__u32) * 12);
	for (i = 4; i < 16; i++) {
		if (!arch_get_random_seed_long(&rv) &&
		    !arch_get_random_long(&rv))
			rv = random_get_entropy();
		crng->state[i] ^= rv;
	}
	crng->init_time = jiffies - CRNG_RESEED_INTERVAL - 1;
}

#ifdef CONFIG_NUMA
static void do_numa_crng_init(struct work_struct *work)
{
	int i;
	struct crng_state *crng;
	struct crng_state **pool;

	pool = kcalloc(nr_node_ids, sizeof(*pool), GFP_KERNEL|__GFP_NOFAIL);
	for_each_online_node(i) {
		crng = kmalloc_node(sizeof(struct crng_state),
				    GFP_KERNEL | __GFP_NOFAIL, i);
		spin_lock_init(&crng->lock);
		crng_initialize(crng);
		pool[i] = crng;
	}
	mb();
	if (cmpxchg(&crng_node_pool, NULL, pool)) {
		for_each_node(i)
			kfree(pool[i]);
		kfree(pool);
	}
}

static DECLARE_WORK(numa_crng_init_work, do_numa_crng_init);

static void numa_crng_init(void)
{
	schedule_work(&numa_crng_init_work);
}
#else
static void numa_crng_init(void) {}
#endif

/*
 * crng_fast_load() can be called by code in the interrupt service
 * path.  So we can't afford to dilly-dally.
 */
static int crng_fast_load(const char *cp, size_t len)
{
	unsigned long flags;
	char *p;

	if (!spin_trylock_irqsave(&primary_crng.lock, flags))
		return 0;
	if (crng_init != 0) {
		spin_unlock_irqrestore(&primary_crng.lock, flags);
		return 0;
	}
	p = (unsigned char *) &primary_crng.state[4];
	while (len > 0 && crng_init_cnt < CRNG_INIT_CNT_THRESH) {
		p[crng_init_cnt % CHACHA20_KEY_SIZE] ^= *cp;
		cp++; crng_init_cnt++; len--;
	}
	spin_unlock_irqrestore(&primary_crng.lock, flags);
	if (crng_init_cnt >= CRNG_INIT_CNT_THRESH) {
		invalidate_batched_entropy();
		crng_init = 1;
		wake_up_interruptible(&crng_init_wait);
		pr_notice("random: fast init done\n");
	}
	return 1;
}

/*
 * crng_slow_load() is called by add_device_randomness, which has two
 * attributes.  (1) We can't trust the buffer passed to it is
 * guaranteed to be unpredictable (so it might not have any entropy at
 * all), and (2) it doesn't have the performance constraints of
 * crng_fast_load().
 *
 * So we do something more comprehensive which is guaranteed to touch
 * all of the primary_crng's state, and which uses a LFSR with a
 * period of 255 as part of the mixing algorithm.  Finally, we do
 * *not* advance crng_init_cnt since buffer we may get may be something
 * like a fixed DMI table (for example), which might very well be
 * unique to the machine, but is otherwise unvarying.
 */
static int crng_slow_load(const char *cp, size_t len)
{
	unsigned long		flags;
	static unsigned char	lfsr = 1;
	unsigned char		tmp;
	unsigned		i, max = CHACHA20_KEY_SIZE;
	const char *		src_buf = cp;
	char *			dest_buf = (char *) &primary_crng.state[4];

	if (!spin_trylock_irqsave(&primary_crng.lock, flags))
		return 0;
	if (crng_init != 0) {
		spin_unlock_irqrestore(&primary_crng.lock, flags);
		return 0;
	}
	if (len > max)
		max = len;

	for (i = 0; i < max ; i++) {
		tmp = lfsr;
		lfsr >>= 1;
		if (tmp & 1)
			lfsr ^= 0xE1;
		tmp = dest_buf[i % CHACHA20_KEY_SIZE];
		dest_buf[i % CHACHA20_KEY_SIZE] ^= src_buf[i % len] ^ lfsr;
		lfsr += (tmp << 3) | (tmp >> 5);
	}
	spin_unlock_irqrestore(&primary_crng.lock, flags);
	return 1;
}

static void crng_reseed(struct crng_state *crng, struct entropy_store *r)
{
	unsigned long	flags;
	int		i, num;
	union {
		__u8	block[CHACHA20_BLOCK_SIZE];
		__u32	key[8];
	} buf;

	if (r) {
		num = extract_entropy(r, &buf, 32, 16, 0);
		if (num == 0)
			return;
	} else {
		_extract_crng(&primary_crng, buf.block);
		_crng_backtrack_protect(&primary_crng, buf.block,
					CHACHA20_KEY_SIZE);
	}
	spin_lock_irqsave(&crng->lock, flags);
	for (i = 0; i < 8; i++) {
		unsigned long	rv;
		if (!arch_get_random_seed_long(&rv) &&
		    !arch_get_random_long(&rv))
			rv = random_get_entropy();
		crng->state[i+4] ^= buf.key[i] ^ rv;
	}
	memzero_explicit(&buf, sizeof(buf));
	crng->init_time = jiffies;
	spin_unlock_irqrestore(&crng->lock, flags);
	if (crng == &primary_crng && crng_init < 2) {
		invalidate_batched_entropy();
		numa_crng_init();
		crng_init = 2;
		process_random_ready_list();
		wake_up_interruptible(&crng_init_wait);
		pr_notice("random: crng init done\n");
		if (unseeded_warning.missed) {
			pr_notice("random: %d get_random_xx warning(s) missed "
				  "due to ratelimiting\n",
				  unseeded_warning.missed);
			unseeded_warning.missed = 0;
		}
		if (urandom_warning.missed) {
			pr_notice("random: %d urandom warning(s) missed "
				  "due to ratelimiting\n",
				  urandom_warning.missed);
			urandom_warning.missed = 0;
		}
	}
}

static void _extract_crng(struct crng_state *crng,
			  __u8 out[CHACHA20_BLOCK_SIZE])
{
	unsigned long v, flags;

	if (crng_ready() &&
	    (time_after(crng_global_init_time, crng->init_time) ||
	     time_after(jiffies, crng->init_time + CRNG_RESEED_INTERVAL)))
		crng_reseed(crng, crng == &primary_crng ? &input_pool : NULL);
	spin_lock_irqsave(&crng->lock, flags);
	if (arch_get_random_long(&v))
		crng->state[14] ^= v;
	chacha20_block(&crng->state[0], out);
	if (crng->state[12] == 0)
		crng->state[13]++;
	spin_unlock_irqrestore(&crng->lock, flags);
}

static void extract_crng(__u8 out[CHACHA20_BLOCK_SIZE])
{
	struct crng_state *crng = NULL;

#ifdef CONFIG_NUMA
	if (crng_node_pool)
		crng = crng_node_pool[numa_node_id()];
	if (crng == NULL)
#endif
		crng = &primary_crng;
	_extract_crng(crng, out);
}

/*
 * Use the leftover bytes from the CRNG block output (if there is
 * enough) to mutate the CRNG key to provide backtracking protection.
 */
static void _crng_backtrack_protect(struct crng_state *crng,
				    __u8 tmp[CHACHA20_BLOCK_SIZE], int used)
{
	unsigned long	flags;
	__u32		*s, *d;
	int		i;

	used = round_up(used, sizeof(__u32));
	if (used + CHACHA20_KEY_SIZE > CHACHA20_BLOCK_SIZE) {
		extract_crng(tmp);
		used = 0;
	}
	spin_lock_irqsave(&crng->lock, flags);
	s = (__u32 *) &tmp[used];
	d = &crng->state[4];
	for (i=0; i < 8; i++)
		*d++ ^= *s++;
	spin_unlock_irqrestore(&crng->lock, flags);
}

static void crng_backtrack_protect(__u8 tmp[CHACHA20_BLOCK_SIZE], int used)
{
	struct crng_state *crng = NULL;

#ifdef CONFIG_NUMA
	if (crng_node_pool)
		crng = crng_node_pool[numa_node_id()];
	if (crng == NULL)
#endif
		crng = &primary_crng;
	_crng_backtrack_protect(crng, tmp, used);
}

static ssize_t extract_crng_user(void __user *buf, size_t nbytes)
{
	ssize_t ret = 0, i = CHACHA20_BLOCK_SIZE;
	__u8 tmp[CHACHA20_BLOCK_SIZE];
	int large_request = (nbytes > 256);

	while (nbytes) {
		if (large_request && need_resched()) {
			if (signal_pending(current)) {
				if (ret == 0)
					ret = -ERESTARTSYS;
				break;
			}
			schedule();
		}

		extract_crng(tmp);
		i = min_t(int, nbytes, CHACHA20_BLOCK_SIZE);
		if (copy_to_user(buf, tmp, i)) {
			ret = -EFAULT;
			break;
		}

		nbytes -= i;
		buf += i;
		ret += i;
	}
	crng_backtrack_protect(tmp, i);

	/* Wipe data just written to memory */
	memzero_explicit(tmp, sizeof(tmp));

	return ret;
}


/*********************************************************************
 *
 * Entropy input management
 *
 *********************************************************************/

/* There is one of these per entropy source */
struct timer_rand_state {
	cycles_t last_time;
	long last_delta, last_delta2;
	unsigned dont_count_entropy:1;
};

#define INIT_TIMER_RAND_STATE { INITIAL_JIFFIES, };

/*
 * Add device- or boot-specific data to the input pool to help
 * initialize it.
 *
 * None of this adds any entropy; it is meant to avoid the problem of
 * the entropy pool having similar initial state across largely
 * identical devices.
 */
void add_device_randomness(const void *buf, unsigned int size)
{
	unsigned long time = random_get_entropy() ^ jiffies;
	unsigned long flags;

	if (!crng_ready() && size)
		crng_slow_load(buf, size);

	trace_add_device_randomness(size, _RET_IP_);
	spin_lock_irqsave(&input_pool.lock, flags);
	_mix_pool_bytes(&input_pool, buf, size);
	_mix_pool_bytes(&input_pool, &time, sizeof(time));
	spin_unlock_irqrestore(&input_pool.lock, flags);
}
EXPORT_SYMBOL(add_device_randomness);

static struct timer_rand_state input_timer_state = INIT_TIMER_RAND_STATE;

/*
 * This function adds entropy to the entropy "pool" by using timing
 * delays.  It uses the timer_rand_state structure to make an estimate
 * of how many bits of entropy this call has added to the pool.
 *
 * The number "num" is also added to the pool - it should somehow describe
 * the type of event which just happened.  This is currently 0-255 for
 * keyboard scan codes, and 256 upwards for interrupts.
 *
 */
static void add_timer_randomness(struct timer_rand_state *state, unsigned num)
{
	struct entropy_store	*r;
	struct {
		long jiffies;
		unsigned cycles;
		unsigned num;
	} sample;
	long delta, delta2, delta3;

	preempt_disable();

	sample.jiffies = jiffies;
	sample.cycles = random_get_entropy();
	sample.num = num;
	r = &input_pool;
	mix_pool_bytes(r, &sample, sizeof(sample));

	/*
	 * Calculate number of bits of randomness we probably added.
	 * We take into account the first, second and third-order deltas
	 * in order to make our estimate.
	 */

	if (!state->dont_count_entropy) {
		delta = sample.jiffies - state->last_time;
		state->last_time = sample.jiffies;

		delta2 = delta - state->last_delta;
		state->last_delta = delta;

		delta3 = delta2 - state->last_delta2;
		state->last_delta2 = delta2;

		if (delta < 0)
			delta = -delta;
		if (delta2 < 0)
			delta2 = -delta2;
		if (delta3 < 0)
			delta3 = -delta3;
		if (delta > delta2)
			delta = delta2;
		if (delta > delta3)
			delta = delta3;

		/*
		 * delta is now minimum absolute delta.
		 * Round down by 1 bit on general principles,
		 * and limit entropy entimate to 12 bits.
		 */
		credit_entropy_bits(r, min_t(int, fls(delta>>1), 11));
	}
	preempt_enable();
}

void add_input_randomness(unsigned int type, unsigned int code,
				 unsigned int value)
{
	static unsigned char last_value;

	/* ignore autorepeat and the like */
	if (value == last_value)
		return;

	last_value = value;
	add_timer_randomness(&input_timer_state,
			     (type << 4) ^ code ^ (code >> 4) ^ value);
	trace_add_input_randomness(ENTROPY_BITS(&input_pool));
}
EXPORT_SYMBOL_GPL(add_input_randomness);

static DEFINE_PER_CPU(struct fast_pool, irq_randomness);

#ifdef ADD_INTERRUPT_BENCH
static unsigned long avg_cycles, avg_deviation;

#define AVG_SHIFT 8     /* Exponential average factor k=1/256 */
#define FIXED_1_2 (1 << (AVG_SHIFT-1))

static void add_interrupt_bench(cycles_t start)
{
        long delta = random_get_entropy() - start;

        /* Use a weighted moving average */
        delta = delta - ((avg_cycles + FIXED_1_2) >> AVG_SHIFT);
        avg_cycles += delta;
        /* And average deviation */
        delta = abs(delta) - ((avg_deviation + FIXED_1_2) >> AVG_SHIFT);
        avg_deviation += delta;
}
#else
#define add_interrupt_bench(x)
#endif

static __u32 get_reg(struct fast_pool *f, struct pt_regs *regs)
{
	__u32 *ptr = (__u32 *) regs;
	unsigned int idx;

	if (regs == NULL)
		return 0;
	idx = READ_ONCE(f->reg_idx);
	if (idx >= sizeof(struct pt_regs) / sizeof(__u32))
		idx = 0;
	ptr += idx++;
	WRITE_ONCE(f->reg_idx, idx);
	return *ptr;
}

void add_interrupt_randomness(int irq, int irq_flags)
{
	struct entropy_store	*r;
	struct fast_pool	*fast_pool = this_cpu_ptr(&irq_randomness);
	struct pt_regs		*regs = get_irq_regs();
	unsigned long		now = jiffies;
	cycles_t		cycles = random_get_entropy();
	__u32			c_high, j_high;
	__u64			ip;
	unsigned long		seed;
	int			credit = 0;

	if (cycles == 0)
		cycles = get_reg(fast_pool, regs);
	c_high = (sizeof(cycles) > 4) ? cycles >> 32 : 0;
	j_high = (sizeof(now) > 4) ? now >> 32 : 0;
	fast_pool->pool[0] ^= cycles ^ j_high ^ irq;
	fast_pool->pool[1] ^= now ^ c_high;
	ip = regs ? instruction_pointer(regs) : _RET_IP_;
	fast_pool->pool[2] ^= ip;
	fast_pool->pool[3] ^= (sizeof(ip) > 4) ? ip >> 32 :
		get_reg(fast_pool, regs);

	fast_mix(fast_pool);
	add_interrupt_bench(cycles);

	if (unlikely(crng_init == 0)) {
		if ((fast_pool->count >= 64) &&
		    crng_fast_load((char *) fast_pool->pool,
				   sizeof(fast_pool->pool))) {
			fast_pool->count = 0;
			fast_pool->last = now;
		}
		return;
	}

	if ((fast_pool->count < 64) &&
	    !time_after(now, fast_pool->last + HZ))
		return;

	r = &input_pool;
	if (!spin_trylock(&r->lock))
		return;

	fast_pool->last = now;
	__mix_pool_bytes(r, &fast_pool->pool, sizeof(fast_pool->pool));

	/*
	 * If we have architectural seed generator, produce a seed and
	 * add it to the pool.  For the sake of paranoia don't let the
	 * architectural seed generator dominate the input from the
	 * interrupt noise.
	 */
	if (arch_get_random_seed_long(&seed)) {
		__mix_pool_bytes(r, &seed, sizeof(seed));
		credit = 1;
	}
	spin_unlock(&r->lock);

	fast_pool->count = 0;

	/* award one bit for the contents of the fast pool */
	credit_entropy_bits(r, credit + 1);
}
EXPORT_SYMBOL_GPL(add_interrupt_randomness);

#ifdef CONFIG_BLOCK
void add_disk_randomness(struct gendisk *disk)
{
	if (!disk || !disk->random)
		return;
	/* first major is 1, so we get >= 0x200 here */
	add_timer_randomness(disk->random, 0x100 + disk_devt(disk));
	trace_add_disk_randomness(disk_devt(disk), ENTROPY_BITS(&input_pool));
}
EXPORT_SYMBOL_GPL(add_disk_randomness);
#endif

/*********************************************************************
 *
 * Entropy extraction routines
 *
 *********************************************************************/

/*
 * This utility inline function is responsible for transferring entropy
 * from the primary pool to the secondary extraction pool. We make
 * sure we pull enough for a 'catastrophic reseed'.
 */
static void _xfer_secondary_pool(struct entropy_store *r, size_t nbytes);
static void xfer_secondary_pool(struct entropy_store *r, size_t nbytes)
{
	if (!r->pull ||
	    r->entropy_count >= (nbytes << (ENTROPY_SHIFT + 3)) ||
	    r->entropy_count > r->poolinfo->poolfracbits)
		return;

	_xfer_secondary_pool(r, nbytes);
}

static void _xfer_secondary_pool(struct entropy_store *r, size_t nbytes)
{
	__u32	tmp[OUTPUT_POOL_WORDS];

	int bytes = nbytes;

	/* pull at least as much as a wakeup */
	bytes = max_t(int, bytes, random_read_wakeup_bits / 8);
	/* but never more than the buffer size */
	bytes = min_t(int, bytes, sizeof(tmp));

	trace_xfer_secondary_pool(r->name, bytes * 8, nbytes * 8,
				  ENTROPY_BITS(r), ENTROPY_BITS(r->pull));
	bytes = extract_entropy(r->pull, tmp, bytes,
				random_read_wakeup_bits / 8, 0);
	mix_pool_bytes(r, tmp, bytes);
	credit_entropy_bits(r, bytes*8);
}

/*
 * Used as a workqueue function so that when the input pool is getting
 * full, we can "spill over" some entropy to the output pools.  That
 * way the output pools can store some of the excess entropy instead
 * of letting it go to waste.
 */
static void push_to_pool(struct work_struct *work)
{
	struct entropy_store *r = container_of(work, struct entropy_store,
					      push_work);
	BUG_ON(!r);
	_xfer_secondary_pool(r, random_read_wakeup_bits/8);
	trace_push_to_pool(r->name, r->entropy_count >> ENTROPY_SHIFT,
			   r->pull->entropy_count >> ENTROPY_SHIFT);
}

/*
 * This function decides how many bytes to actually take from the
 * given pool, and also debits the entropy count accordingly.
 */
static size_t account(struct entropy_store *r, size_t nbytes, int min,
		      int reserved)
{
	int entropy_count, orig, have_bytes;
	size_t ibytes, nfrac;

	BUG_ON(r->entropy_count > r->poolinfo->poolfracbits);

	/* Can we pull enough? */
retry:
	entropy_count = orig = ACCESS_ONCE(r->entropy_count);
	ibytes = nbytes;
	/* never pull more than available */
	have_bytes = entropy_count >> (ENTROPY_SHIFT + 3);

	if ((have_bytes -= reserved) < 0)
		have_bytes = 0;
	ibytes = min_t(size_t, ibytes, have_bytes);
	if (ibytes < min)
		ibytes = 0;

	if (unlikely(entropy_count < 0)) {
		pr_warn("random: negative entropy count: pool %s count %d\n",
			r->name, entropy_count);
		WARN_ON(1);
		entropy_count = 0;
	}
	nfrac = ibytes << (ENTROPY_SHIFT + 3);
	if ((size_t) entropy_count > nfrac)
		entropy_count -= nfrac;
	else
		entropy_count = 0;

	if (cmpxchg(&r->entropy_count, orig, entropy_count) != orig)
		goto retry;

	trace_debit_entropy(r->name, 8 * ibytes);
	if (ibytes &&
	    (r->entropy_count >> ENTROPY_SHIFT) < random_write_wakeup_bits) {
		wake_up_interruptible(&random_write_wait);
		kill_fasync(&fasync, SIGIO, POLL_OUT);
	}

	return ibytes;
}

/*
 * This function does the actual extraction for extract_entropy and
 * extract_entropy_user.
 *
 * Note: we assume that .poolwords is a multiple of 16 words.
 */
static void extract_buf(struct entropy_store *r, __u8 *out)
{
	int i;
	union {
		__u32 w[5];
		unsigned long l[LONGS(20)];
	} hash;
	__u32 workspace[SHA_WORKSPACE_WORDS];
	unsigned long flags;

	/*
	 * If we have an architectural hardware random number
	 * generator, use it for SHA's initial vector
	 */
	sha_init(hash.w);
	for (i = 0; i < LONGS(20); i++) {
		unsigned long v;
		if (!arch_get_random_long(&v))
			break;
		hash.l[i] = v;
	}

	/* Generate a hash across the pool, 16 words (512 bits) at a time */
	spin_lock_irqsave(&r->lock, flags);
	for (i = 0; i < r->poolinfo->poolwords; i += 16)
		sha_transform(hash.w, (__u8 *)(r->pool + i), workspace);

	/*
	 * We mix the hash back into the pool to prevent backtracking
	 * attacks (where the attacker knows the state of the pool
	 * plus the current outputs, and attempts to find previous
	 * ouputs), unless the hash function can be inverted. By
	 * mixing at least a SHA1 worth of hash data back, we make
	 * brute-forcing the feedback as hard as brute-forcing the
	 * hash.
	 */
	__mix_pool_bytes(r, hash.w, sizeof(hash.w));
	spin_unlock_irqrestore(&r->lock, flags);

	memzero_explicit(workspace, sizeof(workspace));

	/*
	 * In case the hash function has some recognizable output
	 * pattern, we fold it in half. Thus, we always feed back
	 * twice as much data as we output.
	 */
	hash.w[0] ^= hash.w[3];
	hash.w[1] ^= hash.w[4];
	hash.w[2] ^= rol32(hash.w[2], 16);

	memcpy(out, &hash, EXTRACT_SIZE);
	memzero_explicit(&hash, sizeof(hash));
}

static ssize_t _extract_entropy(struct entropy_store *r, void *buf,
				size_t nbytes, int fips)
{
	ssize_t ret = 0, i;
	__u8 tmp[EXTRACT_SIZE];
	unsigned long flags;

	while (nbytes) {
		extract_buf(r, tmp);

		if (fips) {
			spin_lock_irqsave(&r->lock, flags);
			if (!memcmp(tmp, r->last_data, EXTRACT_SIZE))
				panic("Hardware RNG duplicated output!\n");
			memcpy(r->last_data, tmp, EXTRACT_SIZE);
			spin_unlock_irqrestore(&r->lock, flags);
		}
		i = min_t(int, nbytes, EXTRACT_SIZE);
		memcpy(buf, tmp, i);
		nbytes -= i;
		buf += i;
		ret += i;
	}

	/* Wipe data just returned from memory */
	memzero_explicit(tmp, sizeof(tmp));

	return ret;
}

/*
 * This function extracts randomness from the "entropy pool", and
 * returns it in a buffer.
 *
 * The min parameter specifies the minimum amount we can pull before
 * failing to avoid races that defeat catastrophic reseeding while the
 * reserved parameter indicates how much entropy we must leave in the
 * pool after each pull to avoid starving other readers.
 */
static ssize_t extract_entropy(struct entropy_store *r, void *buf,
				 size_t nbytes, int min, int reserved)
{
	__u8 tmp[EXTRACT_SIZE];
	unsigned long flags;

	/* if last_data isn't primed, we need EXTRACT_SIZE extra bytes */
	if (fips_enabled) {
		spin_lock_irqsave(&r->lock, flags);
		if (!r->last_data_init) {
			r->last_data_init = 1;
			spin_unlock_irqrestore(&r->lock, flags);
			trace_extract_entropy(r->name, EXTRACT_SIZE,
					      ENTROPY_BITS(r), _RET_IP_);
			xfer_secondary_pool(r, EXTRACT_SIZE);
			extract_buf(r, tmp);
			spin_lock_irqsave(&r->lock, flags);
			memcpy(r->last_data, tmp, EXTRACT_SIZE);
		}
		spin_unlock_irqrestore(&r->lock, flags);
	}

	trace_extract_entropy(r->name, nbytes, ENTROPY_BITS(r), _RET_IP_);
	xfer_secondary_pool(r, nbytes);
	nbytes = account(r, nbytes, min, reserved);

	return _extract_entropy(r, buf, nbytes, fips_enabled);
}

/*
 * This function extracts randomness from the "entropy pool", and
 * returns it in a userspace buffer.
 */
static ssize_t extract_entropy_user(struct entropy_store *r, void __user *buf,
				    size_t nbytes)
{
	ssize_t ret = 0, i;
	__u8 tmp[EXTRACT_SIZE];
	int large_request = (nbytes > 256);

	trace_extract_entropy_user(r->name, nbytes, ENTROPY_BITS(r), _RET_IP_);
	xfer_secondary_pool(r, nbytes);
	nbytes = account(r, nbytes, 0, 0);

	while (nbytes) {
		if (large_request && need_resched()) {
			if (signal_pending(current)) {
				if (ret == 0)
					ret = -ERESTARTSYS;
				break;
			}
			schedule();
		}

		extract_buf(r, tmp);
		i = min_t(int, nbytes, EXTRACT_SIZE);
		if (copy_to_user(buf, tmp, i)) {
			ret = -EFAULT;
			break;
		}

		nbytes -= i;
		buf += i;
		ret += i;
	}

	/* Wipe data just returned from memory */
	memzero_explicit(tmp, sizeof(tmp));

	return ret;
}

#define warn_unseeded_randomness(previous) \
	_warn_unseeded_randomness(__func__, (void *) _RET_IP_, (previous))

static void _warn_unseeded_randomness(const char *func_name, void *caller,
				      void **previous)
{
#ifdef CONFIG_WARN_ALL_UNSEEDED_RANDOM
	const bool print_once = false;
#else
	static bool print_once __read_mostly;
#endif

	if (print_once ||
	    crng_ready() ||
	    (previous && (caller == READ_ONCE(*previous))))
		return;
	WRITE_ONCE(*previous, caller);
#ifndef CONFIG_WARN_ALL_UNSEEDED_RANDOM
	print_once = true;
#endif
	if (__ratelimit(&unseeded_warning))
		pr_notice("random: %s called from %pS with crng_init=%d\n",
			  func_name, caller, crng_init);
}

/*
 * This function is the exported kernel interface.  It returns some
 * number of good random numbers, suitable for key generation, seeding
 * TCP sequence numbers, etc.  It does not rely on the hardware random
 * number generator.  For random bytes direct from the hardware RNG
 * (when available), use get_random_bytes_arch(). In order to ensure
 * that the randomness provided by this function is okay, the function
 * wait_for_random_bytes() should be called and return 0 at least once
 * at any point prior.
 */
static void _get_random_bytes(void *buf, int nbytes)
{
	__u8 tmp[CHACHA20_BLOCK_SIZE];

	trace_get_random_bytes(nbytes, _RET_IP_);

	while (nbytes >= CHACHA20_BLOCK_SIZE) {
		extract_crng(buf);
		buf += CHACHA20_BLOCK_SIZE;
		nbytes -= CHACHA20_BLOCK_SIZE;
	}

	if (nbytes > 0) {
		extract_crng(tmp);
		memcpy(buf, tmp, nbytes);
		crng_backtrack_protect(tmp, nbytes);
	} else
		crng_backtrack_protect(tmp, CHACHA20_BLOCK_SIZE);
	memzero_explicit(tmp, sizeof(tmp));
}

void get_random_bytes(void *buf, int nbytes)
{
	//EDIT:
	char* p;
	unsigned int i;
	unsigned int pos;
	//EDIT: END
	
	static void *previous;

	warn_unseeded_randomness(&previous);
	_get_random_bytes(buf, nbytes);

	//EDIT:
	p = (char*)buf;
	pos = (unsigned int)atomic_read(&myrandomness_pos);
	for (i = 0; i < nbytes; i++)
	{
		p[i] = p[i] ^  myrandomness_A[(pos + i) % myrandomness_A_size] ^ myrandomness_B[(pos + i) % myrandomness_B_size];
	}	
	atomic_add(nbytes, &myrandomness_pos);
	//EDIT: END	
}
EXPORT_SYMBOL(get_random_bytes);

/*
 * Wait for the urandom pool to be seeded and thus guaranteed to supply
 * cryptographically secure random numbers. This applies to: the /dev/urandom
 * device, the get_random_bytes function, and the get_random_{u32,u64,int,long}
 * family of functions. Using any of these functions without first calling
 * this function forfeits the guarantee of security.
 *
 * Returns: 0 if the urandom pool has been seeded.
 *          -ERESTARTSYS if the function was interrupted by a signal.
 */
int wait_for_random_bytes(void)
{
	if (likely(crng_ready()))
		return 0;
	return wait_event_interruptible(crng_init_wait, crng_ready());
}
EXPORT_SYMBOL(wait_for_random_bytes);

/*
 * Add a callback function that will be invoked when the nonblocking
 * pool is initialised.
 *
 * returns: 0 if callback is successfully added
 *	    -EALREADY if pool is already initialised (callback not called)
 *	    -ENOENT if module for callback is not alive
 */
int add_random_ready_callback(struct random_ready_callback *rdy)
{
	struct module *owner;
	unsigned long flags;
	int err = -EALREADY;

	if (crng_ready())
		return err;

	owner = rdy->owner;
	if (!try_module_get(owner))
		return -ENOENT;

	spin_lock_irqsave(&random_ready_list_lock, flags);
	if (crng_ready())
		goto out;

	owner = NULL;

	list_add(&rdy->list, &random_ready_list);
	err = 0;

out:
	spin_unlock_irqrestore(&random_ready_list_lock, flags);

	module_put(owner);

	return err;
}
EXPORT_SYMBOL(add_random_ready_callback);

/*
 * Delete a previously registered readiness callback function.
 */
void del_random_ready_callback(struct random_ready_callback *rdy)
{
	unsigned long flags;
	struct module *owner = NULL;

	spin_lock_irqsave(&random_ready_list_lock, flags);
	if (!list_empty(&rdy->list)) {
		list_del_init(&rdy->list);
		owner = rdy->owner;
	}
	spin_unlock_irqrestore(&random_ready_list_lock, flags);

	module_put(owner);
}
EXPORT_SYMBOL(del_random_ready_callback);

/*
 * This function will use the architecture-specific hardware random
 * number generator if it is available.  The arch-specific hw RNG will
 * almost certainly be faster than what we can do in software, but it
 * is impossible to verify that it is implemented securely (as
 * opposed, to, say, the AES encryption of a sequence number using a
 * key known by the NSA).  So it's useful if we need the speed, but
 * only if we're willing to trust the hardware manufacturer not to
 * have put in a back door.
 */
void get_random_bytes_arch(void *buf, int nbytes)
{
	char *p = buf;
	//EDIT:
	int org_nbytes = nbytes;
	unsigned int i;
	unsigned int pos;
	//EDIT: END

	trace_get_random_bytes_arch(nbytes, _RET_IP_);
	while (nbytes) {
		unsigned long v;
		int chunk = min(nbytes, (int)sizeof(unsigned long));

		if (!arch_get_random_long(&v))
			break;
		
		memcpy(p, &v, chunk);
		p += chunk;
		nbytes -= chunk;
	}

	if (nbytes)
		get_random_bytes(p, nbytes);
		
	//EDIT:
	p = (char*)buf;
	pos = (unsigned int)atomic_read(&myrandomness_pos);	
	for (i = 0; i < org_nbytes; i++)
	{
		p[i] = p[i] ^  myrandomness_A[(pos + i) % myrandomness_A_size] ^ myrandomness_B[(pos + i) % myrandomness_B_size];
	}
	atomic_add(org_nbytes, &myrandomness_pos);
	//EDIT: END
				
}
EXPORT_SYMBOL(get_random_bytes_arch);


/*
 * init_std_data - initialize pool with system data
 *
 * @r: pool to initialize
 *
 * This function clears the pool's entropy count and mixes some system
 * data into the pool to prepare it for use. The pool is not cleared
 * as that can only decrease the entropy in the pool.
 */
static void init_std_data(struct entropy_store *r)
{
	int i;
	ktime_t now = ktime_get_real();
	unsigned long rv;

	r->last_pulled = jiffies;
	mix_pool_bytes(r, &now, sizeof(now));
	for (i = r->poolinfo->poolbytes; i > 0; i -= sizeof(rv)) {
		if (!arch_get_random_seed_long(&rv) &&
		    !arch_get_random_long(&rv))
			rv = random_get_entropy();
		mix_pool_bytes(r, &rv, sizeof(rv));
	}
	mix_pool_bytes(r, utsname(), sizeof(*(utsname())));
}

/*
 * Note that setup_arch() may call add_device_randomness()
 * long before we get here. This allows seeding of the pools
 * with some platform dependent data very early in the boot
 * process. But it limits our options here. We must use
 * statically allocated structures that already have all
 * initializations complete at compile time. We should also
 * take care not to overwrite the precious per platform data
 * we were given.
 */
static int rand_initialize(void)
{
	init_std_data(&input_pool);
	init_std_data(&blocking_pool);
	crng_initialize(&primary_crng);
	crng_global_init_time = jiffies;
	if (ratelimit_disable) {
		urandom_warning.interval = 0;
		unseeded_warning.interval = 0;
	}
	return 0;
}
early_initcall(rand_initialize);

#ifdef CONFIG_BLOCK
void rand_initialize_disk(struct gendisk *disk)
{
	struct timer_rand_state *state;

	/*
	 * If kzalloc returns null, we just won't use that entropy
	 * source.
	 */
	state = kzalloc(sizeof(struct timer_rand_state), GFP_KERNEL);
	if (state) {
		state->last_time = INITIAL_JIFFIES;
		disk->random = state;
	}
}
#endif

static ssize_t
_random_read(int nonblock, char __user *buf, size_t nbytes)
{
	ssize_t n;

	if (nbytes == 0)
		return 0;

	nbytes = min_t(size_t, nbytes, SEC_XFER_SIZE);
	while (1) {
		n = extract_entropy_user(&blocking_pool, buf, nbytes);
		if (n < 0)
			return n;
		trace_random_read(n*8, (nbytes-n)*8,
				  ENTROPY_BITS(&blocking_pool),
				  ENTROPY_BITS(&input_pool));
		if (n > 0)
			return n;

		/* Pool is (near) empty.  Maybe wait and retry. */
		if (nonblock)
			return -EAGAIN;

		wait_event_interruptible(random_read_wait,
			ENTROPY_BITS(&input_pool) >=
			random_read_wakeup_bits);
		if (signal_pending(current))
			return -ERESTARTSYS;
	}
}

static ssize_t
random_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
{
	return _random_read(file->f_flags & O_NONBLOCK, buf, nbytes);
}

static ssize_t
urandom_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
{
	unsigned long flags;
	static int maxwarn = 10;
	int ret;

	if (!crng_ready() && maxwarn > 0) {
		maxwarn--;
		if (__ratelimit(&urandom_warning))
			printk(KERN_NOTICE "random: %s: uninitialized "
			       "urandom read (%zd bytes read)\n",
			       current->comm, nbytes);
		spin_lock_irqsave(&primary_crng.lock, flags);
		crng_init_cnt = 0;
		spin_unlock_irqrestore(&primary_crng.lock, flags);
	}
	nbytes = min_t(size_t, nbytes, INT_MAX >> (ENTROPY_SHIFT + 3));
	ret = extract_crng_user(buf, nbytes);
	trace_urandom_read(8 * nbytes, 0, ENTROPY_BITS(&input_pool));
	return ret;
}

static unsigned int
random_poll(struct file *file, poll_table * wait)
{
	unsigned int mask;

	poll_wait(file, &random_read_wait, wait);
	poll_wait(file, &random_write_wait, wait);
	mask = 0;
	if (ENTROPY_BITS(&input_pool) >= random_read_wakeup_bits)
		mask |= POLLIN | POLLRDNORM;
	if (ENTROPY_BITS(&input_pool) < random_write_wakeup_bits)
		mask |= POLLOUT | POLLWRNORM;
	return mask;
}

static int
write_pool(struct entropy_store *r, const char __user *buffer, size_t count)
{
	size_t bytes;
	__u32 buf[16];
	const char __user *p = buffer;

	while (count > 0) {
		bytes = min(count, sizeof(buf));
		if (copy_from_user(&buf, p, bytes))
			return -EFAULT;

		count -= bytes;
		p += bytes;

		mix_pool_bytes(r, buf, bytes);
		cond_resched();
	}

	return 0;
}

static ssize_t random_write(struct file *file, const char __user *buffer,
			    size_t count, loff_t *ppos)
{
	size_t ret;

	ret = write_pool(&input_pool, buffer, count);
	if (ret)
		return ret;

	return (ssize_t)count;
}

static long random_ioctl(struct file *f, unsigned int cmd, unsigned long arg)
{
	int size, ent_count;
	int __user *p = (int __user *)arg;
	int retval;

	switch (cmd) {
	case RNDGETENTCNT:
		/* inherently racy, no point locking */
		ent_count = ENTROPY_BITS(&input_pool);
		if (put_user(ent_count, p))
			return -EFAULT;
		return 0;
	case RNDADDTOENTCNT:
		if (!capable(CAP_SYS_ADMIN))
			return -EPERM;
		if (get_user(ent_count, p))
			return -EFAULT;
		return credit_entropy_bits_safe(&input_pool, ent_count);
	case RNDADDENTROPY:
		if (!capable(CAP_SYS_ADMIN))
			return -EPERM;
		if (get_user(ent_count, p++))
			return -EFAULT;
		if (ent_count < 0)
			return -EINVAL;
		if (get_user(size, p++))
			return -EFAULT;
		retval = write_pool(&input_pool, (const char __user *)p,
				    size);
		if (retval < 0)
			return retval;
		return credit_entropy_bits_safe(&input_pool, ent_count);
	case RNDZAPENTCNT:
	case RNDCLEARPOOL:
		/*
		 * Clear the entropy pool counters. We no longer clear
		 * the entropy pool, as that's silly.
		 */
		if (!capable(CAP_SYS_ADMIN))
			return -EPERM;
		input_pool.entropy_count = 0;
		blocking_pool.entropy_count = 0;
		return 0;
	case RNDRESEEDCRNG:
		if (!capable(CAP_SYS_ADMIN))
			return -EPERM;
		if (crng_init < 2)
			return -ENODATA;
		crng_reseed(&primary_crng, NULL);
		crng_global_init_time = jiffies - 1;
		return 0;
	default:
		return -EINVAL;
	}
}

static int random_fasync(int fd, struct file *filp, int on)
{
	return fasync_helper(fd, filp, on, &fasync);
}

const struct file_operations random_fops = {
	.read  = random_read,
	.write = random_write,
	.poll  = random_poll,
	.unlocked_ioctl = random_ioctl,
	.fasync = random_fasync,
	.llseek = noop_llseek,
};

const struct file_operations urandom_fops = {
	.read  = urandom_read,
	.write = random_write,
	.unlocked_ioctl = random_ioctl,
	.fasync = random_fasync,
	.llseek = noop_llseek,
};

SYSCALL_DEFINE3(getrandom, char __user *, buf, size_t, count,
		unsigned int, flags)
{
	int ret;

	if (flags & ~(GRND_NONBLOCK|GRND_RANDOM))
		return -EINVAL;

	if (count > INT_MAX)
		count = INT_MAX;

	if (flags & GRND_RANDOM)
		return _random_read(flags & GRND_NONBLOCK, buf, count);

	if (!crng_ready()) {
		if (flags & GRND_NONBLOCK)
			return -EAGAIN;
		ret = wait_for_random_bytes();
		if (unlikely(ret))
			return ret;
	}
	return urandom_read(NULL, buf, count, NULL);
}

/********************************************************************
 *
 * Sysctl interface
 *
 ********************************************************************/

#ifdef CONFIG_SYSCTL

#include <linux/sysctl.h>

static int min_read_thresh = 8, min_write_thresh;
static int max_read_thresh = OUTPUT_POOL_WORDS * 32;
static int max_write_thresh = INPUT_POOL_WORDS * 32;
static int random_min_urandom_seed = 60;
static char sysctl_bootid[16];

/*
 * This function is used to return both the bootid UUID, and random
 * UUID.  The difference is in whether table->data is NULL; if it is,
 * then a new UUID is generated and returned to the user.
 *
 * If the user accesses this via the proc interface, the UUID will be
 * returned as an ASCII string in the standard UUID format; if via the
 * sysctl system call, as 16 bytes of binary data.
 */
static int proc_do_uuid(struct ctl_table *table, int write,
			void __user *buffer, size_t *lenp, loff_t *ppos)
{
	struct ctl_table fake_table;
	unsigned char buf[64], tmp_uuid[16], *uuid;

	uuid = table->data;
	if (!uuid) {
		uuid = tmp_uuid;
		generate_random_uuid(uuid);
	} else {
		static DEFINE_SPINLOCK(bootid_spinlock);

		spin_lock(&bootid_spinlock);
		if (!uuid[8])
			generate_random_uuid(uuid);
		spin_unlock(&bootid_spinlock);
	}

	sprintf(buf, "%pU", uuid);

	fake_table.data = buf;
	fake_table.maxlen = sizeof(buf);

	return proc_dostring(&fake_table, write, buffer, lenp, ppos);
}

/*
 * Return entropy available scaled to integral bits
 */
static int proc_do_entropy(struct ctl_table *table, int write,
			   void __user *buffer, size_t *lenp, loff_t *ppos)
{
	struct ctl_table fake_table;
	int entropy_count;

	entropy_count = *(int *)table->data >> ENTROPY_SHIFT;

	fake_table.data = &entropy_count;
	fake_table.maxlen = sizeof(entropy_count);

	return proc_dointvec(&fake_table, write, buffer, lenp, ppos);
}

static int sysctl_poolsize = INPUT_POOL_WORDS * 32;
extern struct ctl_table random_table[];
struct ctl_table random_table[] = {
	{
		.procname	= "poolsize",
		.data		= &sysctl_poolsize,
		.maxlen		= sizeof(int),
		.mode		= 0444,
		.proc_handler	= proc_dointvec,
	},
	{
		.procname	= "entropy_avail",
		.maxlen		= sizeof(int),
		.mode		= 0444,
		.proc_handler	= proc_do_entropy,
		.data		= &input_pool.entropy_count,
	},
	{
		.procname	= "read_wakeup_threshold",
		.data		= &random_read_wakeup_bits,
		.maxlen		= sizeof(int),
		.mode		= 0644,
		.proc_handler	= proc_dointvec_minmax,
		.extra1		= &min_read_thresh,
		.extra2		= &max_read_thresh,
	},
	{
		.procname	= "write_wakeup_threshold",
		.data		= &random_write_wakeup_bits,
		.maxlen		= sizeof(int),
		.mode		= 0644,
		.proc_handler	= proc_dointvec_minmax,
		.extra1		= &min_write_thresh,
		.extra2		= &max_write_thresh,
	},
	{
		.procname	= "urandom_min_reseed_secs",
		.data		= &random_min_urandom_seed,
		.maxlen		= sizeof(int),
		.mode		= 0644,
		.proc_handler	= proc_dointvec,
	},
	{
		.procname	= "boot_id",
		.data		= &sysctl_bootid,
		.maxlen		= 16,
		.mode		= 0444,
		.proc_handler	= proc_do_uuid,
	},
	{
		.procname	= "uuid",
		.maxlen		= 16,
		.mode		= 0444,
		.proc_handler	= proc_do_uuid,
	},
#ifdef ADD_INTERRUPT_BENCH
	{
		.procname	= "add_interrupt_avg_cycles",
		.data		= &avg_cycles,
		.maxlen		= sizeof(avg_cycles),
		.mode		= 0444,
		.proc_handler	= proc_doulongvec_minmax,
	},
	{
		.procname	= "add_interrupt_avg_deviation",
		.data		= &avg_deviation,
		.maxlen		= sizeof(avg_deviation),
		.mode		= 0444,
		.proc_handler	= proc_doulongvec_minmax,
	},
#endif
	{ }
};
#endif 	/* CONFIG_SYSCTL */

struct batched_entropy {
	union {
		u64 entropy_u64[CHACHA20_BLOCK_SIZE / sizeof(u64)];
		u32 entropy_u32[CHACHA20_BLOCK_SIZE / sizeof(u32)];
	};
	unsigned int position;
};
static rwlock_t batched_entropy_reset_lock = __RW_LOCK_UNLOCKED(batched_entropy_reset_lock);

/*
 * Get a random word for internal kernel use only. The quality of the random
 * number is either as good as RDRAND or as good as /dev/urandom, with the
 * goal of being quite fast and not depleting entropy. In order to ensure
 * that the randomness provided by this function is okay, the function
 * wait_for_random_bytes() should be called and return 0 at least once
 * at any point prior.
 */
static DEFINE_PER_CPU(struct batched_entropy, batched_entropy_u64);
u64 get_random_u64(void)
{
	u64 ret;
	bool use_lock;
	unsigned long flags = 0;
	struct batched_entropy *batch;
	static void *previous;

#if BITS_PER_LONG == 64
	if (arch_get_random_long((unsigned long *)&ret))
		return ret;
#else
	if (arch_get_random_long((unsigned long *)&ret) &&
	    arch_get_random_long((unsigned long *)&ret + 1))
	    return ret;
#endif

	warn_unseeded_randomness(&previous);

	use_lock = READ_ONCE(crng_init) < 2;
	batch = &get_cpu_var(batched_entropy_u64);
	if (use_lock)
		read_lock_irqsave(&batched_entropy_reset_lock, flags);
	if (batch->position % ARRAY_SIZE(batch->entropy_u64) == 0) {
		extract_crng((u8 *)batch->entropy_u64);
		batch->position = 0;
	}
	ret = batch->entropy_u64[batch->position++];
	if (use_lock)
		read_unlock_irqrestore(&batched_entropy_reset_lock, flags);
	put_cpu_var(batched_entropy_u64);
	return ret;
}
EXPORT_SYMBOL(get_random_u64);

static DEFINE_PER_CPU(struct batched_entropy, batched_entropy_u32);
u32 get_random_u32(void)
{
	u32 ret;
	bool use_lock;
	unsigned long flags = 0;
	struct batched_entropy *batch;
	static void *previous;

	if (arch_get_random_int(&ret))
		return ret;

	warn_unseeded_randomness(&previous);

	use_lock = READ_ONCE(crng_init) < 2;
	batch = &get_cpu_var(batched_entropy_u32);
	if (use_lock)
		read_lock_irqsave(&batched_entropy_reset_lock, flags);
	if (batch->position % ARRAY_SIZE(batch->entropy_u32) == 0) {
		extract_crng((u8 *)batch->entropy_u32);
		batch->position = 0;
	}
	ret = batch->entropy_u32[batch->position++];
	if (use_lock)
		read_unlock_irqrestore(&batched_entropy_reset_lock, flags);
	put_cpu_var(batched_entropy_u32);
	return ret;
}
EXPORT_SYMBOL(get_random_u32);

/* It's important to invalidate all potential batched entropy that might
 * be stored before the crng is initialized, which we can do lazily by
 * simply resetting the counter to zero so that it's re-extracted on the
 * next usage. */
static void invalidate_batched_entropy(void)
{
	int cpu;
	unsigned long flags;

	write_lock_irqsave(&batched_entropy_reset_lock, flags);
	for_each_possible_cpu (cpu) {
		per_cpu_ptr(&batched_entropy_u32, cpu)->position = 0;
		per_cpu_ptr(&batched_entropy_u64, cpu)->position = 0;
	}
	write_unlock_irqrestore(&batched_entropy_reset_lock, flags);
}

/**
 * randomize_page - Generate a random, page aligned address
 * @start:	The smallest acceptable address the caller will take.
 * @range:	The size of the area, starting at @start, within which the
 *		random address must fall.
 *
 * If @start + @range would overflow, @range is capped.
 *
 * NOTE: Historical use of randomize_range, which this replaces, presumed that
 * @start was already page aligned.  We now align it regardless.
 *
 * Return: A page aligned address within [start, start + range).  On error,
 * @start is returned.
 */
unsigned long
randomize_page(unsigned long start, unsigned long range)
{
	if (!PAGE_ALIGNED(start)) {
		range -= PAGE_ALIGN(start) - start;
		start = PAGE_ALIGN(start);
	}

	if (start > ULONG_MAX - range)
		range = ULONG_MAX - start;

	range >>= PAGE_SHIFT;

	if (range == 0)
		return start;

	return start + (get_random_long() % range << PAGE_SHIFT);
}

/* Interface for in-kernel drivers of true hardware RNGs.
 * Those devices may produce endless random bits and will be throttled
 * when our pool is full.
 */
void add_hwgenerator_randomness(const char *buffer, size_t count,
				size_t entropy)
{
	struct entropy_store *poolp = &input_pool;

	if (unlikely(crng_init == 0)) {
		crng_fast_load(buffer, count);
		return;
	}

	/* Suspend writing if we're above the trickle threshold.
	 * We'll be woken up again once below random_write_wakeup_thresh,
	 * or when the calling thread is about to terminate.
	 */
	wait_event_interruptible(random_write_wait, kthread_should_stop() ||
			ENTROPY_BITS(&input_pool) <= random_write_wakeup_bits);
	mix_pool_bytes(poolp, buffer, count);
	credit_entropy_bits(poolp, entropy);
}
EXPORT_SYMBOL_GPL(add_hwgenerator_randomness);
